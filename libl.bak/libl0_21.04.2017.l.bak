*** **************************
*** Начало чего то
*** **************************
printLComplex(L1/)
	Oi
	§100 *printf(L1i/) ∆i /' '>C ↑(i<Q1)100
**

printFComplex(F1/)
	Oi
	§100 *printf(F1i/) ∆i /' '>C ↑(i<Q1)100
**

*** вывод комплекса с отрицательными числами
sprint_complex(L1/)
	Oi
	§100 *sprintf(L1i/) ∆i /' '>C ↑(i<Q1)100
**

*** вывод отрицательного числа
*** 19.04.2016 ВНИМАНИЕ: не всегда работает правильно, например на ffffffffh
sprintf(x/)
	@+F1(100) OQ1
	x&ffff0000h⇒y x⇒t
	↑(y=0)1 0-x⇒t /'-'>C
	§1
		*n2s(t,10/F1)
		/F1>C
**



*** обернуть эту функцию в алгоритм поиска функции эйлера
*** количество взаимнопростых чисел из разложения числа работает в тандеме с trial_division_method
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** n - число для которого ищется функция эйлера
*** c - количество взаимнопростых
numbOfCoprimes(L1,n/c)
	1⇒c n⇒q Oi
	§1 L1i-1⇒b q/L1i⇒q c*b⇒c ∆i ↑(i≥Q1)2 →1 ***/'ef: b = '>C *printf(b/) /'\n'>C
	§2 q*c⇒c
**


*** ТРЕБУЕТСЯ ДОДЕЛАТЬ: пропускать числа из L1, которые уже были
*** количество взаимнопростых чисел из разложения числа работает в тандеме с trial_division_method_v2
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** c - количество взаимнопростых
numbOfCoprimes_v2(L1,n/c)
	1⇒c Oi
	§1 L1i-1⇒b c*b⇒c ∆i ↑(i≥Q1)2 →1 ***/'ef: b = '>C *printf(b/) /'\n'>C
	§2
**


*** **************************
*** Конец чего то
*** **************************

n(a/b) 
	a+'A'⇒b ↑(a<10)1 a-10+'A'⇒b
	§1
**

n2c(a/b) 
	a+'0'⇒b ↑(a<10)1 a-10+'A'⇒b 
	§1
** 


s2n(F1,q/a)
	Oi
	§1 ↑(i≥Q1)2
			F1i⇒c
			*c2n(c/b)
			a*q+b⇒a
			∆i →1
	§2 
**


decstrtoperem(F1/a)
	Oi
	F1i-'0'⇒a
	§1 ∆i ↑(i=Q1)3
	§2 a*10+F1i-'0'⇒a →1
	§3
**


genm(n,m/L1)
	32-n⇒k
	T;100⇒s
	Oj
	Oi
	§5 Oa
	§6 X ∆a
	§7 ↑(a<s)6
	§1 X>k⇒L1i ∆i ↑(i<m)5
	§3 m⇒Q1
**

*** Наибольший общий делитель
GCD(a,b/b)
	§1 OZ a:b⇒q b⇒a Z⇒b ↑(b>1)1
**




invertible_element_old(a, b/y, c)
	Of a⇒c b⇒d 0⇒y 1⇒w Os ↑(a≠0)1 1⇒y b⇒c →6
	§1	/'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2	∆s ↑(d=0)3 c/d⇒q *printf(d/) /'	'>C *printf(w/) /'	'>C *printf(q/) /'\n'>C
		q*d⇒r c-r⇒r q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3	↑(c≠1)5 s;2⇒f ↑(f>0)4 →6
	§4	↑(y=0)6 a-y⇒y →6
	§5	/'Error: Im sorry, but there is no invertible element GCD != 1\n'>C Oy Oc
	§6 /'\n'>C
**


*** в отличии от старого заменена операция деления с остатком на OZ c:d
invertible_element(a, b/y, c)
	Of a⇒c b⇒d 0⇒y 1⇒w Os ↑(a≠0)1 1⇒y b⇒c →6
	§1	*** /'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2	∆s ↑(d=0)3 OZ c:d⇒q Z⇒r *** *printf(d/) /'	'>C *printf(w/) /'	'>C *printf(q/) /'\n'>C
		q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3	↑(c≠1)5 s;2⇒f ↑(f>0)4 →6
	§4	↑(y=0)6 a-y⇒y →6
	§5	/'Error: Im sorry, but there is no invertible element GCD != 1\n'>C Oy Oc
	§6 *** /'\n'>C
**



*** Расширенный Алгоритм Евклида
*** x - a*x+b*y=c
*** y - a*x+b*y=c
*** c - наибольший общий делитель чисел a и b
*** f - признак отрицательности чисел x или y
*** f = 0 => x < 0
*** f = 1 => y < 0
*** a - входное число для GCD(a, b)
*** b - входное число для GCD(a, b)
Extended_Euclidean_Algorithm(a, b/x, y, c, f)
	Of⇒y+1⇒w a⇒c b⇒d ↑(a≠0)1 ∆y b⇒c →6
	§1 *** /'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2 ∆f;2⇒f ↑(d=0)3 OZ c:d⇒q Z⇒r *** *printf(d/) /'	'>C  *printf(w/) /'	'>C *printf(q/) /'\n'>C
		*** q*d⇒r c-r⇒r
		q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3
		/'f = '>C *printf(f/) /'\n'>C
		/'b = '>C *printf(b/) /'\n'>C
		/'y = '>C *printf(y/) /'\n'>C
		/'c = '>C *printf(c/) /'\n'>C
		/'a = '>C *printf(a/) /'\n'>C
		↑(f>0)5 b*y-c/a⇒x →6
	§5 b*y+c/a⇒x →6
	§6	*** /'\n'>C
**



 
*** 
*** q - система счисления
*** i - следующая пустая позиция
scanf(F1, i, q/a, i)
	***↑(Q1=0)5
	Oa 10⇒q
	↑(i≥Q1)5
	§1 ↑(i≥Q1)4	*** может быть ошибка
  		F1i⇒c
  		↑(c≠' ')2 ∆i →4
  §2
      *c2n(c/b) ***/'b='>C *printf(b/) /'\n'>C
      *** /'q='>C *printf(q/) /'\n'>C
      a*q+b⇒a  ***/'a='>C *printf(a/) /'\n'>C
      ∆i →1
	§5	/'ERROR: Пустой массив(scanf)\n'>C
  §4
**
 


printf(k/)
	@+F1(100)
	OQ1
	*n2s(k,10/F1)
	/F1>C
**




Hprintf(a/)
	@+F1(100)
	@'0x'>F1
	Oi 15⇒y Of
	§1 ↑(i≥8)4
			i+1*4⇒s
			16<1-s⇒s *** *printf(s/) /'\n'>C
			a>s⇒x x&y⇒x *** *printf(x/) /'\n'>C
			↑(x=0)2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F1 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F1 →1
	§4 ↑(Q1=2)5 /F1>C
	§5
**





n2s(a,q/F1)
	§1 a;q⇒b a/q⇒a b+'0'⇒c ↑(b<10)2 'A'+b-10@>F1 →3
	§2 c@>F1
	§3 a↦1 *pervec(F1/F1)
**


c2n(a/b)
	§1 a-'0'⇒b
		↑(b<10)2
		a-'A'+10⇒b
		↑(a<'Z')2
		a-'a'+10⇒b
	§2 
**




*** Дихотомический алг-тм возведения в степень числа
*** x - число возводимое в степень, y - степень этого числа, m - модуль
pow(x, y, m/z)
	Oj ∆j x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i *** /'j = '>C *printf(j/) /'\n'>C ∆j
		 ↑(i>y)5 OZ q*q:m Z⇒q *** /'q = '>C *Hprintf(q/) /'\n'>C
		 i&y↪3 OZ z*q:m Z⇒z *** /'z = '>C *Hprintf(z/) /'\n'>C
		 →3
	§5
**

pow_kostyl(x, y, m/z)
	@+L1(2)
	@+L2(2)
	@+L3(2)
	@+L4(4)
	x⇒L1.0 y⇒L2.0 m⇒L3.0 1⇒Q1⇒Q2⇒Q3
	*powBN(L1, L2, L3/L4)
	L4.0⇒z
**

*** наверное не работает, надо проверять 02.12.2015
pow1(x, y/L1)
	@+L2()
	@+L3()
	x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i ↑(i>y)5 q*q⇒q *** *printf(q/) /'\n'>C
		 i&y↪3 z*q⇒z *** *printf(z/) /'\n'>C
		 →3
	§5
**

pervec(F1/F1)
	Oi Q1-1⇒j
	§1 ↑(i≥j)2 F1i⇒t F1j⇒F1i t⇒F1j ∆i ∇j →1
	§2
**





*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
*** tdMeth(n/L2)
*** tridMeth(n/L2)
*** tdAlg(n/L2)
trial_division_method_v2(n/L2)
	@+L1(100)
	n⇒b
	Oj *countZeroes(n/s) *** /'s = '>C *printf(s/) /'\n'>C
	
	§9 ↑(s=j)8
		2⇒L2j ∆j →9
	§8
	100⇒Q1 *recalc_efficients(L1, 3/L1)
	
	↑(n<2)6 n>s⇒n
	*** n;2⇒k ↑(k=0)4 *** k↪4 одно и тоже с ↑(k=0)4, но не работает
	Oi *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 OZ n:L1i⇒q Z⇒r ↑(r≠0)4 *** n;L1i⇒r n/L1i⇒q ↑(r≠0)4
		*** /'n = '>C *printf(n/) /'\n'>C
		*** /'r = '>C *printf(r/) /'\n'>C
		*** /'q = '>C *printf(q/) /'\n'>C
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
	§3 L1i⇒L2j ∆j q⇒n →1
	§4 ↑(L1i≥q)5
		 ∆i ↑(i<Q1)2 Oi Q1-1⇒l *recalc_efficients(L1, L1l/L1) →1 *** возможно придётся i присваивать 1
	§5 n⇒L2j ∆j →7
	§6 /'ОШИБКА: Число должно быть больше 1\n'>C
	§7 b⇒n j⇒Q2
**


*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
*** L3 - степени сомножителей
trial_division_method(n/L2, L3)
	
	@+L1(100)
	n⇒b
	Oj⇒f *countZeroes(n/s) *** /'s = '>C *printf(s/) /'\n'>C
	↑(s=0)8 2⇒L2j s⇒L3j ∆j OL3j
	§8
		100⇒Q1 *recalc_efficients(L1, 3/L1)
		↑(n<2)6 n>s⇒n *** /'n = '>C *printf(n/) /'\n'>C
	Oi *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 OZ n:L1i⇒q Z⇒r ↑(r≠0)4 *** n;L1i⇒r n/L1i⇒q ↑(r≠0)4
		*** /'n = '>C *printf(n/) /'\n'>C /'r = '>C *printf(r/) /'\n'>C /'q = '>C *printf(q/) /'\n'>C
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
		1⇒f ∆L3j L1i⇒L2j q⇒n →1
	§4 ↑(L1i≥q)5
		∆i j+f⇒j Of⇒L3j ↑(i<Q1)2 Oi Q1-1⇒l *recalc_efficients(L1, L1l/L1) →1 *** возможно придётся i присваивать 1
	§5 j+f⇒j Of n⇒L2j ∆L3j ∆j →7
	§6 /'ОШИБКА: Число должно быть больше 1\n'>C →9
	§7 b⇒n j+f⇒Q2⇒Q3
	§9
**



*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method на маленьком числе
*** и большом числе, с условием, что большое число не предполагается делить на другое большое число
*** мощность комплекса всегда должна быть чётной
*** k - число - начало счёта последовательности
recalc_efficients(L1, k/L1)
	k⇒L1.0⇒l 2⇒d Oi+1⇒i
	§1 ↑(l≥5)2 l+d⇒L1i⇒l ∆i
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method для маленьких чисел
recalc_efficients_v2(L1/L1)
	*** Q1⇒t t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	Q1⇒t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	↑(t≠0)2
	§1 2⇒d
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 *** Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**



*** Тест Миллера-Рабина
*** возвращает значение b равное 1, если вероятно простое, 0, если составное
*** выбран вариант роста a на двойку после 3ёх: 2, 3, 5, 7,....
*** также можно добавить вариант со случайным значением a он закомментирован ниже
*** n - проверяемое число, r - количество раундов
miral(n, r/b)
	*** @+L1(20)
	*** @+L2(20)
	*** @+L3(20)
	*** OQ1⇒Q2 ***⇒Q3
	n-1⇒m Oq⇒s⇒b ∆q
	↑(n=1)5
	*countZeroes(m/s) *** на этой строке считается s - степень двойки (2^s)*t+1
	q<s⇒q m/q⇒t
	*** /'q = '>C *printf(q/) /'\n'>C
	Oi⇒j⇒c ∆c 2⇒a
	§1 ↑(i≥r)4 ↑(a≥m)4
		*** m-1⇒a X;a⇒a ↑(a<2)1 *** поиск псевдослучайного значения от 2 до n-2
		*pow(a, t, n/x)
		*** /'a = '>C *printf(a/) /'\n'>C
		∆i a+c⇒a 2⇒c
		↑(x=1)1 ↑(x=m)1 1⇒j
	§2 ↑(j≥s)5
		 *** x⇒L1.0 n⇒L2.0 1⇒Q1⇒Q2
		 *** /'x = '>C *printf(x/) /'\n'>C
		 *** *pow(x, 2, n/x)
		 x*x:n Z⇒x
		 *** L1*L1;L2⇒L1 L1.0⇒x
		 ↑(x=1)5 ↑(x=m)1 ∆j →2
	§4 ∆b *** /'Вероятно простое\n'>C *** иначе составное
	§5
**

*** формирует простое число из k бит
randPrime(k/t)
	↑(k<2)3 ↑(k>32)3
	§1
		 32-k⇒t k-1⇒c
		 X>t∨1∨Ic⇒t
		 *** /'t = '>C *printf(t/) /'\n'>C
		 *miral(t, 5/b) *** /'b = '>C *printf(b/) /'\n'>C
		 b↪1
	§3
**


*** формирует список простых чисел в которых k бит
randPrimesList(k, l/L1)
	Oi⇒Q1 ↑(k<2)3 ↑(k>32)3
	§1
		 32-k⇒t k-1⇒c
		 X>t∨1∨Ic⇒t
		 *** /'t = '>C *printf(t/) /'\n'>C
		 *miral(t, 5/b) *** /'b = '>C *printf(b/) /'\n'>C
		 b↪2 *** ↑(b=0)2
		 t⇒L1i ∆i i⇒Q1 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
	§2 ↑(i=l)3 →1
	§3
**

countZeroes(x/s)
	Os ↑(x=0)2 1⇒t t&x⇒a
	§1 ↑(a≠0)2 ∆s t<1⇒t t&x⇒a →1
	§2
**



*** Поиск первообразного корня
*** m - модуль
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** r - первообразный корень
primroot(m/r)
	Or
	@+L1(100)
	@+L2(100)
	*** @+L3(100)
	m-1=n *trial_division_method(n/L1,L2) 1=r *** *printf(n/) /' '>C *print_trtr(L1,L2/) /'\n'>C
	P1 r+1=r Oj *** *printf(r/) /'\n'>C
		P2 n/L1j=d *pow(r,d,m/b)
			 *** /'j = '>C *printf(j/) /'\n'>C
			 ?(b=1)1 Dj ?(j>=Q1)4 ?=2
	P4
**


*** Поиск первообразных корней
*** m - модуль
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** r - первообразный корень
primroots(m/L2)
	@+L1(100)
	OQ2=i m-1=n *trial_division_method(n/L1,L2) 1=r *** *printf(n/) /' '>C *print_trtr(L1,L2/) /'\n'>C
	*numbOfCoprimes(L1,n/f) f;100=f *** /'f = '>C *printf(f/) /'\n'>C
	P1 r+1=r Oj *** *printf(r/) /'\n'>C
		P2 n/L1j=d *pow(r,d,m/b)
			 *** /'b = '>C *printf(b/) /'\n'>C
			 ?(b=1)1 Dj ?(j>=Q1)3 ?=2
			P3 r=L2i Yf Di=Q2 ?(f=0)4 ?=1
	P4 *** *print_complex(L2/)
**


*****************************************************************
***************	Алгоритмы над большими числами	*****************
*****************************************************************



div_mul_test(L1, L2/L3)
	@+L4(100)
	L1⇒L3⇒L4
	L1/L2 *** *HprintfBN(L4/)
	L4;L2 *** *HprintfBN(L3/)
	L1*L2+L4 *** *HprintfBN(L3/)
**

*** генерация случайного значения
*** randBN(L1/)
randBN(L1/)
	Q1⇒i X
	§1 i↪2 ∇i OL1i
	X&ffff0000h∨L1i⇒L1i X>16&0000ffffh∨L1i⇒L1i →1
	§2
**



*** ввод большого числа [Добавить обработку нуля!!!]
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
*** big_int_input(L2, F1, i/L2, k) - старое название
inputBN(L2, F1, i/L2, k)
	@+F3(1)
	Oj⇒l⇒s *** /F1>C
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	*** /'i= '>C *printf(i/) /'\n'>C
	↑(F1i≠'0')7 ∆i ↑(F1i≠'x')7 ∆i⇒l⇒e
	*** /'e= '>C *printf(e/) /'\n'>C
	
	§10 ↑(l=Q1)11 ↑(F1l=32)11 ↑(F1l=10)11 ∆l
	*** /'l = '>C *printf(l/) /'\n'>C
	→10
	§11 l⇒k-1⇒i i-e+1/8⇒Q2 i-e+1;8⇒t ∆k Ol OL2l ↑(t=0)1 Q2+1⇒Q2
	§1
		1⇒Q3 F1i⇒F3.0 /F3>C
		*** *printf(i/) /' '>C
		↑(F1i<48)7 ↑(F1i>57)2 F1i-'0'⇒x →4
	§2
		↑(F1i<65)7 ↑(F1i>70)3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<97)7 ↑(F1i>102)7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<e)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное. Возможно не хватает 0x вначале\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 *cutZerosBN(L2/L2)
**


*** ввод большого числа 2ой вариант [Добавить обработку нуля!!!]
*** одна строка - одно число
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
*** big_int_input(L2, F1, i/L2, k) - старое название
inputBN_2(L2, F1/L2)
	Oj Ol Os
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	↑(F1.0≠'0')7 ↑(F1.1≠'x')7
	
	Q1-1⇒i-1/8⇒Q2 OL2l
	*** /'i = '>C *printf(i/) /'\n'>C
	*** /'Q2 = '>C *printf(Q2/) /'\n'>C
	i-1;8↪1 Q2+1⇒Q2
	§1
			*** GLITCH не сработало сравнение ?(F1i>'9')#
		↑(F1i<48)7 ↑(F1i>57)2 F1i-'0'⇒x →4
	§2
		↑(F1i<65)7 ↑(F1i>70)3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<97)7 ↑(F1i>102)7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<2)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное. Возможно не хватает 0x вначале\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 *cutZerosBN(L2/L2)
**






*** вывод большого числа в шестнадцатеричном виде
*** 0x0 будет выводиться только если мощность комплекса Q равна 1
*** если там будет больше элементов и все будут нули, то на выходе получится "0x"
*** закомментированные окончания строк 352, 353, 355 убраны и добавлена переменная l для избежания ситуации выше с 0x, теперь если большое число равно 0, то на выходе будет 0x0 2=>l здесь для затирания 0, если число не равно ему
*** printHexBN(L1/)
*** printHBN(L1/)
*** printhBN(L1/)
*** HprintfBN(L1/)
HprintfBN(L1/)
	@+F2(100)
	↑(Q1=0)7
	Oi⇒f 4⇒s Q1-1⇒j 15⇒y '0'@>F2 'x'@>F2 '0'@>F2 2⇒l+1⇒Q2
	§1 ↑(i≥8)4
			***/'j= '>C *printf(j/) /'\n'>C
			16<1-s⇒t ***/'t= '>C *printf(t/) /'\n'>C	*** 16 для оптимизации под конкретную архитектуру
			L1j>t⇒x x&y⇒x s+4⇒s *** /'x= '>C *printf(x/) /'\n'>C
			*** *Hprintf(L1j/)
			x↪2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'⇒F2l ∆l⇒Q2 →1 *** ∆l⇒Q2 для того, чтобы обрабатывался ноль, как 0x0
	§3 ∆i ↑(f=0)1 x+'0'⇒F2l ∆l⇒Q2 →1 *** связано с 2⇒l+1⇒Q2
	§4 ↑(j=0)5 4⇒s ∇j Oi →1 *** ↑(j≥Q1)5
	§5 ↑(Q1>1)6 *** ↑(L1.0>0)6 '0'@>F2
	§6 /F2>C
	§7
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3*2⇒l *optimize(L5, l/L5)
	§1
		↑(i≥32)3 Ii&L2j↪2
		*** /'#############\n'>C
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L5= '>C *HprintfBN(L5/) /'\n'>C
		*** /'#############\n'>C
		L5*L6;L3⇒L6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'Q6 = '>C *printf(Q6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n'>C
		
		*** L6;L3⇒L6 *** /'33\n'>C *** Q3⇒Q6
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	   
	§2
		L5*L5;L3⇒L5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	   *** /'Q5 = '>C *printf(Q5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом баррета взятия по модулю
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_bar(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	@+L7(1000)
	
	Q3*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L3⇒L7 *** L7 = z
	
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	*** L1;L3=L5 не заменяется на barmod(...)
	L1;L3⇒L5 Q3*2⇒l
	§1
		↑(i≥32)3 *optimize(L5, l/L5) *** в barmod обрезается мощность и без этого не работает
		Ii&L2j↪2 *** Q5+Q6⇒l *optimize(L6, l/L6)
		L5*L6⇒L6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'11\n'>C
		*barmod(L6, L3, L7/L6) *** Q3⇒Q6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		 L5*L5⇒L5
		 *barmod(L5, L3, L7/L5) *** Q3⇒Q5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом Карацубы
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_karat(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3+Q3⇒l *optimize(L6, l/L6) *optimize(L5, l/L5)
	§1
		↑(i≥32)3 Ii&L2j↪2
		*** /'#############\n'>C
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L5= '>C *HprintfBN(L5/) /'\n'>C
		*** /'#############\n'>C
		*karatsuba(L5, L6/L6)
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'Q6 = '>C *printf(Q6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n'>C
		L6;L3⇒L6 Q3⇒Q6
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		*karatsuba(L5, L5/L5) L5;L3⇒L5 Q3⇒Q5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	   *** /'Q5 = '>C *printf(Q5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом Карацубы и методом баррета взятия по модулю
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_mix(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	@+L7(1000)
	
	Q3*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L3⇒L7 *** L7 = z
	
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3+Q3⇒l *optimize(L6, l/L6) *optimize(L5, l/L5)
	§1
		 ↑(i≥32)3 Ii&L2j↪2
		 *karatsuba(L5, L6/L6) *barmod(L6, L3, L7/L6)
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		 *karatsuba(L5, L5/L5) *barmod(L5, L3, L7/L5)
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**



*** /'d L4= '>C *HprintfBN(L4/)
*** /'Q4= '>C *printf(Q4/) /' '>C
*** /'d L5= '>C *HprintfBN(L5/)


optimize(L1, n/L1)
	Q1⇒i n⇒Q1
	§1 ↑(i≥n)2 OL1i ∆i →1
	§2 
**

*** Метод пробных делений на больших числах
*** на входе всегда нечётное число
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** L9 - степени сомножителей
*** s -  степень числа
*** /'Q2 = '>C *printf(Q2/) /'\n'>C
*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
tdmBN(L1/L3, L4, L9)
	@+L7(100) ***(Q1)
	@+L2(100)
	@+L5(100)
	Q1⇒Q7 L1⇒L7 Oj⇒f
	*countZeroesBN(L1/s)
	↑(s=0)11 2⇒L3j s⇒L9j ∆j OL9j
	§11 Of  L1>s⇒L1 *cutZerosBN(L1/L1)
		 ↑(Q1>1)8 L1.0⇒n *trial_division_method(n/L2, L5) Oi
	§12
		 ↑(i≥Q2)9 L2i⇒L3i L5i⇒L9i ∆i-1⇒j+1⇒Q9⇒Q3 →12
	§8
		 @+L6(1)
		 100⇒Q2 *recalc_efficients(L2, 3/L2) 1⇒Q4⇒Q5⇒Q6 OQ3 3⇒L6.0
		 *BN_less(L7, L6/b) ↑(b=1)6
		 Oi *** возможно придётся i присваивать 1
	§1 1⇒L6.0 *BN_eq(L1, L6/b)
		 ↑(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	§2 ↑(L2i<3)10 L2i⇒L6.0
		 L1/L6⇒L4 L1;L6⇒L5 *cutZerosBN(L4/L4) *cutZerosBN(L5/L5) OL6
	*** ↑(L2i<145900)3 /'L2i = '>C *printf(L2i/) /'\n'>C /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	*** §3	 
		 *BN_neq(L5, L6/b) ↑(b≠0)4
		 1⇒f ∆L9j L2i⇒L3j Q4⇒Q1 L4⇒L1 →1
	§4 L2i⇒L6.0
		 *BN_greq(L6, L4/b)
		 ↑(b=1)5
		∆i j+f⇒j Of⇒L9j ↑(i<Q2)2 Oi Q2-1⇒l *recalc_efficients(L2, L2l/L2)
		→1 *** возможно придётся i присваивать 1
	§5 ↑(Q1>1)13 j+f⇒j Of L1.0⇒L3j ∆L9j ∆j OL4 OQ4 →9
	§13
		 Q1⇒Q4 L1⇒L4 *cutZerosBN(L4/L4) →9
	§6 /'Число должно быть больше 2'>C
	§10 /'unsigned int числа закончились\n'>C
	§9 j+f⇒Q3⇒Q9 Q7⇒Q1 L7⇒L1
**


*** Метод пробных делений на больших числах без комплекса степеней чисел
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** здесь j это t, а i это k
*** все сравнения BN_*(*/?) делаются без учёта мощностей комплексов(больших чисел), потому что результаты арифметических операций над ними не возвращают новую мощность результата 08.12.2015
*** s -  степень числа
*** ndc - no degrees complex
tdmBN_ndc(L1/L3, L4)
	@+L7(100) ***(Q1)
	@+L2(100)
	*countZeroesBN(L1/s) s⇒t
	Q1⇒Q7 L1⇒L7 *cutZerosBN(L1/L1)
	§12 ↑(t=0)11 2⇒L3j ∆j ∇t →12
	§11 
		 ↑(Q1>1)8 L1.0⇒n *trial_division_method(n/L2) Oi
	§13
		 ↑(i≥Q2)9 L2i⇒L3j ∆i ∆j⇒Q3 →13
	§8
		 @+L5(100)
		 @+L6(1)
		 
		 100⇒Q2 *recalcefficients(L2, 3/L2) 1⇒Q4⇒Q5⇒Q6 OQ3
		 3⇒L6.0
		 *BN_less(L1, L6/b) ↑(b=1)6 L1>s⇒L1 *cutZerosBN(L1/L1)
		 Oi *** возможно придётся i присваивать 1
	§1 1⇒L6.0 *BN_eq(L4, L6/b)
		 ↑(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	§2 ↑(L2i<3)10 L2i⇒L6.0
		 L1;L6⇒L5 *cutZerosBN(L5/L5) L1/L6⇒L4 *cutZerosBN(L4/L4) OL6
		 *BN_neq(L5, L6/b)
		 ↑(b≠0)4
		 *** Возможна ошибка, если мощность комплекса больше 1, но число равно 0
		 L2i⇒L3j
		 ∆j L4⇒L1 →1
	§4 L2i⇒L6.0
		 *** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		 *BN_greq(L6, L4/b)
		 ↑(b=1)5
		∆i ↑(i<Q2)2 Oi Q2-1⇒l *recalcefficients(L2, L2l/L2)
		*** *printf(L2.0/) /'\n'>C *printf(L2.1/) /'\n'>C *printf(L2.2/) /'\n'>C *printf(L2.3/) /'\n'>C
		→1 *** возможно придётся i присваивать 1
	§5 ↑(Q1>1)14 L1.0⇒L3j ∆j OQ4 →9
	§14
		 Q1⇒Q4 L1⇒L4 *cutZerosBN(L4/L4)
		 *** /'Q1 = '>C *Hprintf(Q4/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L4/) /'\n'>C
		 →9
	§6 /'Число должно быть больше 2'>C
	§10 /'unsigned int числа закончились\n'>C
	§9 j⇒Q3⇒Q9 Q7⇒Q1 L7⇒L1
		 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
		 *** /'Q7 = '>C *printf(Q7/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 *** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
**



*** функция сжимает большое число - уменьшает его мощность, если впереди есть нулевые элементы
*** применяется после арифметических операций, где возможно уменьшение мощности числа, но сами арифметические операции его не уменьшают 08.12.2015
cutZerosBN(L1/L1)
	Q1-1⇒i
	§1 ↑(L1i≠0)2 ↑(i=0)2 i⇒Q1 ∇i →1
	§2
**


*** Дихотомический алг-тм возведения в небольшую степень большого числа
*** L1 - число возводимое в степень, y - степень этого числа, L2 - модуль
*** думаю в нём нет смысла, если использовать метод из pow(), можно убрать модуль, тогда получится большое число в степени "маленького" числа
powBN1(L1, y, L2/L4)
	*** @+L4(100)
	@+L3(100)
	
	1⇒Q4⇒Q5
	L1⇒L3 Q2+Q2⇒l *optimize(L3, l/L3) *optimize(L4, l/L4) 1⇒L4.0⇒i
	y&1↪3 L1⇒L4 *optimize(L4, l/L4)
	§3 i<1⇒i ↑(i>y)5 L3*L3;L2⇒L3
		 *** /'Q5= '>C *printf(Q5/) /'\n'>C
		 i&y↪3 L3*L4;L2⇒L4
		 *** /'L4= '>C *HprintfBN(L4/) /'\n'>C
		 →3
	§5
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа
*** L4 - q, L3 - z 
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN2(L1, L2/L3)
	@+L4(100)
	
	1⇒Q4⇒Q5 Oj
	L1⇒L4 Q3+Q3⇒l *optimize(L4, l/L4) *optimize(L3, l/L3) 1⇒L3.0⇒i⇒s i<1⇒i L2j&1↪1 L1⇒L3 *optimize(L3, l/L3)
	§1 ↑(s≥32)3 L4*L4⇒L4
	   *** /'L4= '>C *HprintfBN(L4/)
		 i&L2j↪2 L4*L3⇒L3
	   *** /'L3= '>C *HprintfBN(L3/)
	§2 ∆s i<1⇒i →1
	§3 ∆j ↑(j≥Q2)4 Os 1⇒i →1
	§4 *cutZerosBN(L3/L3)
**

*** возможно ли, что степень двойки будет большим числом?
*** проблема - может прийти комплекс с мощностью больше 1, но равный нулю
countZeroesBN(L1/s)
	↑(Q1=0)4 Oi⇒s ↑(Q1>1)1 ↑(L1.0=0)5
	§1 ↑(i≥Q1)3 ↑(L1i≠0)2 s+32⇒s ∆i →1
	§2 *countZeroes(L1i/b) *** /'czs = '>C *printf(s/) /'\n'>C
		 *** /'b = '>C *printf(b/) /'\n'>C
		 s+b⇒s
		 *** /'s = '>C *printf(s/) /'\n'>C
		 *** /'i = '>C *printf(i/) /'\n'>C
	§3 s/Q1⇒t s;Q1⇒l t+l⇒l ↑(l=32)5 →6
	§4 /'ОШИБКА: Мощность комплекса равна нулю\n'>C
	§5 Os /'ОШИБКА: Комплекс полностью из нулей\n'>C
	§6
**


*** генерация простого числа
*** k - количество бит
*** l - максимально возможная длина числа (количество элементов)
*** L1 - число
randPrimeBN(k/L1)
	Oi⇒Q1⇒s⇒t ↑(k<2)4
	§1 OZ k:32⇒t Z⇒s
		31⇒c ↑(s=0)2 s-1⇒c ∆t
	§2
		↑(t>S1)4 t⇒Q1 Is-1⇒s ↑(s>0)3 ffffffffh⇒s
	§3
		*randBN(L1/)
		*** /'t = '>C *printf(t/) /'\n'>C
		 Q1-1⇒t
		 *** /'rBN s = '>C *printf(s/) /'\n'>C
		 *** /'begin c = '>C *printf(c/) /'\n'>C
		 *** /'t = '>C *printf(t/) /'\n'>C
		 L1.0∨1⇒L1.0 L1t∨Ic⇒L1t s&L1t⇒L1t
		 *** /'Current Number: '>C *HprintfBN(L1/) /'\n'>C
		 *miralBN(L1, 5/b)
		 *** /'b = '>C *printf(b/) /'\n'>C
		  b↪3 *** ↑(b=0)3
	§4 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
**

*** miller-rabin-algorithm()
*** r - количество раундов, есть ли смысл делать большим числом?
*** может ли степень s быть больше 32 бит?
*** L1 - n простое нечётное число
*** 
*** 
*** 
*** 
miralBN(L1, r/b)
	Q1*2⇒n
	@+L3(n) *** m ⇒ n-1 (L1-1)
	@+L4(n) *** q, потом t n ⇒ (q^2)*t+1
	*** @+L5(20) *** t
	@+L6(n) *** i, до начала индексации промежуточный комплекс
	@+L7(n) *** a
	@+L8(n) *** 1ца, 2ка для последовательности 2, 3, 5 ,7,...
	*** @+L9(20) *** 
	@+L10(n) *** x
	*** @+L11(20) *** j на случай, если степень двойки(число s) будет большим числом
	
	1⇒L4.0⇒Q6⇒Q4⇒Q3 Ob
	*BN_eq(L1, L3/c) ↑(c=1)5
	Q1⇒Q3 OL3 1⇒L3.0
	L1-L3⇒L3 *** L3 теперь m ⇒ n-1 (L1-1)
	*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
	*countZeroesBN(L3/s)
	L4<s⇒L4
	*** /'s = '>C *printf(s/) /'\n'>C
	*** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
	L3/L4⇒L4
	Oj⇒i 1⇒L8.0⇒L6.0 2⇒L7.0 1⇒Q7⇒Q8⇒Q6
	§1 ↑(i≥r)4 *BN_greq(L7, L3/c) ↑(c=1)4
		 *** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		 *** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
		 *** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 *powBN(L7, L4, L1/L10)
		 *** /'L10 = '>C *HprintfBN(L10/) /'\n'>C
		 ∆i L7+L8⇒L7 1⇒L8.0
		 *** /'L7^L4 mod L1 = '>C *HprintfBN(L10/) /'\n'>C
		 **** /'L8 = '>C *HprintfBN(L8/) /'\n'>C
		 *** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
		 
		 *BN_eq(L10, L8/c) 2⇒L8.0 ↑(c=1)1
		 *BN_eq(L10, L3/c) ↑(c=1)1
		 1⇒j
	§2 ↑(j≥s)5
		 *** /'L10 = '>C *HprintfBN(L10/) /'\n'>C
		 *** /'L8 = '>C *HprintfBN(L8/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 L10*L10;L1⇒L10 1⇒L8.0
		 *** 2⇒L8.0 *powBN(L10, L8, L1/L10) 1⇒L8.0
		 *** /'L10^L8 mod L1 = '>C *HprintfBN(L10/) /'\n'>C
		 *BN_eq(L10, L8/c) 2⇒L8.0 ↑(c=1)5 *BN_eq(L10, L3/c) ↑(c=1)1 ∆j →2
	§4 ∆b *** /'Вероятно простое\n'>C
	§5
**


*** возможно ли, что степень двойки будет большим числом?
*** проблема - может прийти комплекс с мощностью больше 1, но равный нулю
countZeroesBN(L1/s)
	↑(Q1=0)4 Oi⇒s ↑(Q1>1)1 ↑(L1.0=0)5
	§1 ↑(i≥Q1)3 ↑(L1i≠0)2 s+32⇒s ∆i →1
	§2 *countZeroes(L1i/b) *** /'czs = '>C *printf(s/) /'\n'>C
		 *** /'b = '>C *printf(b/) /'\n'>C
		 s+b⇒s
		 *** /'s = '>C *printf(s/) /'\n'>C
		 *** /'i = '>C *printf(i/) /'\n'>C
	§3 s/Q1⇒t s;Q1⇒l t+l⇒l ↑(l=32)5 →6
	§4 /'ОШИБКА: Мощность комплекса равна нулю\n'>C
	§5 Os /'ОШИБКА: Комплекс полностью из нулей\n'>C
	§6
**


*** Алгоритм карацубы перемножения 2ух больших чисел
*** http://samos-it.com/posts/recursive-karatsuba-multiplication-python.html
*** f - признак нулевого комплекса - требуется восстановить значение 0
karatsuba(L1, L2/L3)
	@+L4(1000) *** 1ая половина L1 b
	@+L5(1000) *** 2ая половина L1 a
	@+L6(1000) *** 1ая половина L2 d
	@+L7(1000) *** 2ая половина L2 c
	@+L8(1000) *** результат первых половин ab
	@+L9(1000) *** результат вторых половин cd
	@+L11(1000)
	@+L12(1000)
	
	Q1⇒Q11 L1⇒L11 Q2⇒Q12 L2⇒L12
	
	*** Q2 сравнивается со старым значением Q1 (t)
	*** мощность одного из комплексов увеличивается до максимума n
	Q12⇒n/2⇒w ↑(Q12=Q11)2 ↑(Q12>Q11)1 Q11⇒n/2⇒w *optimize(L12, n/L12) →2
	§1
		*optimize(L11, n/L11)
	§2
		↑(n>50)3
		n*2⇒Q3 OL3 1⇒L3.0 L3*L11*L12⇒L3 *cutZerosBN(L3/L3) →8
	
	§3
		n;2↪4 n⇒t+1⇒Q11⇒Q12⇒n/2⇒w OL12t OL11t
	§4
		L11⇒L5 Q11-w⇒Q5⇒Q4-1⇒t OL4t Q11-w*32⇒t L11>t⇒L4 w⇒Q4
		L12⇒L7 Q12-w⇒Q7⇒Q6-1⇒t OL6t Q12-w*32⇒t L12>t⇒L6 w⇒Q6
		*karatsuba(L4, L6/L8) *** A
		*karatsuba(L5, L7/L9) *** B
		*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
		Q4⇒t+1⇒Q4 OL4t
		Q6⇒t+1⇒Q6 OL6t
		L4+L5⇒L4 L6+L7⇒L6
		Q4-1⇒t ↑(L4t>0)5 t⇒Q4
	§5
		Q6-1⇒t ↑(L6t>0)6 t⇒Q6
	§6
		*karatsuba(L4, L6/L3) *** C
		*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n\n'>C
		Q3⇒t+w⇒Q3 OL3t
		w⇒q<5⇒t
		L3-L8-L9⇒L3
		L3<t⇒L3
		32*n⇒t n+Q8⇒Q8 L8<t⇒L8
		*** Здесь возможна ситуация, когда мощность L3
		*** больше L8, тогда требуется к L3 добавить
		*** содержимое двух комплексов L8 и L9
		*** иначе(Q8>Q3) к L8 добавить L3 и L9
		↑(Q8>Q3)7 L3+L8+L9⇒L3 →8
		*** Q3⇒l *optimize(L8, l/L8)
	§7
		L8+L3+L9⇒L3
	§8
**




*** Алгоритм баррета приведения числа по модулю
*** L1 - x число
*** L2 - m модуль
***
***
*** L3 - z
*** L3 = [(b^2k)/L2] ~ z = [(b^2k)/m]
*** Q2*2⇒Q3 OL3
*** Q3⇒k+1⇒Q3 1⇒L3k L3/L2⇒L3
*** 
*** Q2*2⇒Q3 OL3
*** Q3⇒k+1⇒Q3 1⇒L3k L3/L2⇒L3 *** L3 = z
*** L4 - q, r2, r(результат)
*** base ⇒ 2^32 ⇒ 0x100000000
barmod(L1, L2, L3/L4)
	*** /'		Barret\n'>C
	*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
	*** /'L2 = '>C *HprintfBN(L2/) /'\n'>C
	*** /'L3(z) = '>C *HprintfBN(L3/) /'\n'>C
	
	*** 32=b
	@+L5(1000) *** r1
	@+L6(1000) *** r'
	@+L7(1000)
	
	*** Если b = 0x100000000 тогда b^2k = 1^(2*(k+1)*32)?
	
	
	
	Q2-1*32⇒k *** /'k = '>C *printf(k/) /'\n'>C
	Q2+1*32⇒t *** /'t = '>C *printf(t/) /'\n'>C
	*** /'			L1 = '>C *HprintfBN(L1/) /'\n'>C
	L1>k⇒L7 Q7+Q3⇒l *optimize(L7, l/L7) L7*L3⇒L7 L7>t⇒L7 *** L7 = q
	*** /'Q7 = '>C *printf(Q7/) /'\n'>C
	*** /'L7(q`) = '>C *HprintfBN(L7/) /'\n'>C
	*** /'r1 = '>C
	L1⇒L5 Q2+1⇒Q5 *** *HprintfBN(L5/) /'\n'>C *** L5 = r1
	*** /'r2 = '>C
	L7*L2⇒L7 Q2+1⇒Q7 *** *HprintfBN(L7/) /'\n'>C *** L7 = r2
	*** /'Q7 = '>C *printf(Q7/) /'\n'>C
	*** /'Q5 = '>C *printf(Q5/) /'\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
	*** /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	
	*** GLITCH: в Q5 оказалось значение Q1
	
	
	
	*** /'L5(r1) = '>C *HprintfBN(L5/) /'\n'>C
	*** /'L7(r2) = '>C *HprintfBN(L7/) /'\n'>C
	*** /'L6(r`) = '>C *HprintfBN(L6/) /'\n'>C
	
	
	*BN_greq(L5, L7/c) ↑(c=0)1 L5-L7⇒L6 →2
	§1
		L5+L6-L7⇒L6
	§2
		*** /'bar L6 = '>C *HprintfBN(L6/) /'\n'>C
		*cutZerosBN(L6/L6) *BN_greq(L6, L2/c)
		↑(c=0)3 L6-L2⇒L6 →2
	§3
		*** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		Q6⇒Q4 L6⇒L4 *** L7 = r(результат)
	
	
	*** *Hprintf(L1.0/) /'\n'>C
	*** *Hprintf(L2.0/) /'\n'>C
	*** /'k = '>C *printf(k/) /'\n'>C
	*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
**




*** проверка, что 2 больших числа равны
BN_eq(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что большое число L1 больше числа L2
BN_gr(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆b ↑(L2i<L1i)2 Ob ∆i ↑(i<n)1
	§2
**

*** проверка, что большое число L1 меньше числа L2
BN_less(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob
	§1 ↑(L1i>L2i)2 ∆b ↑(L2i>L1i)2 Ob ∆i ↑(i<Q1)1
	§2
**

*** проверка, что большое число L1 больше ил равно числу L2
BN_greq_old(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**


*** проверка, что большое число L1 больше ил равно числу L2
BN_greq(L1, L2/b)
	Ob Q1-1⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	§1 ∆b ↑(L1i>L2i)2 Ob ↑(L1i<L2i)2 ∇i ↑(i<Q1)1 ∆b
	§2
**


*** проверка, что большое число L1 меньше или равно числу L2
BN_leq(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i>L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что 2 больших числа не равны
BN_neq(L1, L2/b)
	Ob⇒i ∆b
	↑(Q1<Q2)2 ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 Ob
	§2
**



******************************************************************************
****************	Алгоритмы над большими числами закончились	****************
******************************************************************************



*******************************************************************
****************	Алгоритмы над булевыми функциями ****************
*******************************************************************

*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1, L2/L2)
	Oj Q1-1⇒i Q1⇒L2.0-1⇒n ∆j OL2j
	§1 F1i-48↦2 L2j<1⇒L2j ∇i →3
	§2 L2j∨1<1⇒L2j ∇i
	§3 ↑(i=0)5 →1
	§4 ∆j OL2j →1
	§5
**

*** 
*** n - размер булевой функции
*** вывод булевой функции
BFoutput(L1/)
	@+F2(1)
	1⇒i⇒Q2 Oz⇒c L1.0⇒n
	§1 1<z⇒t L1i&t>z+48⇒F2.0 ∆c
		 /F2>C /'\n'>C
		 ∆z ↑(z=31)2 ↑(c=n)3 →1
	§2 Oz ∆i ↑(i=Q1)3 →1
	§3
**


********************************************************************************
****************	Алгоритмы над булевыми функциями закончились	****************
********************************************************************************



main(/)
   @+F1(1000) @+F2(100)
   @'liblf.l'>F2  /F2>C /'\n'>C
   *fopen(F2,0/a)
   *peper(a/)
   *freadf(a,F1,0,150/b)
   *peper(b/)
   *fclose(a/) OQ2
   @'liblf.txt'>F2 /F2>C /'\n'>C
   *fopen(F2,1/a)
   *peper(a/)
   *fwritef(a,F1,0,150/b)
   *peper(b/)
   **
********************************************************************
*** работа с файлами
********************************************************************
*** Открытие файла
*** F1 - имя файла (в текущем каталоге)
*** r - режим открытия: 0 - чтение, 1 - запись, 2 - чтение/запись
*** n  - дескриптор файла (<0 при отказе)
********************************************************************
fopen(F1,r/n)
   0@>F1
   {mov eax,5}
   {mov ebx,[ebp+220]}
   {mov ecx,[ebp+72]}
   {int 80h}
   {mov [ebp+56],eax}
   **
********************************************************************
*** Закрытие файла
*** n  - дескриптор файла
********************************************************************
fclose(n/)
   {mov eax,6}
   {mov ebx,[ebp+56]}
   {int 80h}
   **
********************************************************************
*** Чтение из файла в символьный комплекс
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого считанного байта
*** l - число запрашиваемых байт
*** k - число считанных байтов (код ошибки для <0)
********************************************************************
freadf(n,F1,b,l/k)
   {mov eax,3}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **
********************************************************************
*** Запись из символьного комплекса в файл
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого записываемого байта
*** l - число записывемых байт
*** k - число записанных байтов (код ошибки для <0)
********************************************************************
fwritef(n,F1,b,l/k)
   {mov eax,4}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **

   
   
   
   
   
   
   
   
   
*** Ошибки:


matrixoutput(L1,m,n/) 
 @+F2(34)
 Oa
 §1 *binperemtostr(L1a,n/F2) ∆a
 §2 /F2>C /'\n'>C ↑(a<m)1 **



binstrtoperem(F1/x)
 Oi
 Ox
 Q1-1⇒j
*** Q1-1⇒i
 §1 ↑(F1i='0')2 x|Ij⇒x
 §2 ∇j ∆i ↑(i<Q1)1 **




out3(a,b,n/F1)
 OQ1
 n-1⇒i
 §1 a&Ii⇒x x↦2 '1'@>F1 ↑(i=0)3 ∇i →1
 §2 '0'@>F1 ↑(i=0)3 ∇i →1
 §3 /'a⇒ ' /F1>C /'\n'>C
 OQ1
 n-1⇒i
 §4 b&Ii⇒x x↦5 '0'@>F1 ↑(i=0)6 ∇i →1
 §5 '1'@>F1 ↑(i=0)6 ∇i →4
 §6 /'b⇒ ' /F1>C /'\n'>C **



*** вывод булевого вектора на экран
printbv(a, n/)
    31⇒i ∇n
 §1 ↑(i>n)3
    a&Ii ↪2 /' 1'>C →3
 §2 /' 0'>C
 §3 i↪4 ∇i →1
 §4 /'\n'>C **

*** вывод булевой матрицы на экран
printbm(L1,n/)
    Oi
 §1 *printbv(L1i,n/) ∆i ↑(i<Q1)1 /'\n'>C **
	

*** перевод числа в строку *** 

***************************************
numout(a/)
	@+F1(10)
	OQ1 
	§1	a/q⇒a Z⇒b *n(b/c) c@>F1 a↦1 
  §2	Oi Q1⇒a-1⇒j 
  §3	↑(i≥j)4  =(F1ij) ∆i ∇j →3 
  §4   ** 

 
 
binperemtostr(x,n/F1)
 OQ1
 n-1⇒i
 §1 x&Ii⇒a a↦2 '0'@>F1 ↑(i=0)3 ∇i →1
 §2 '1'@>F1 ↑(i=0)3 ∇i →1
 §3 **
