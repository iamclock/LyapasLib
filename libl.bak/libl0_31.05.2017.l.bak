*** **************************
*** Начало чего то
*** **************************
print_complex(L1/)
	Oi
	§100 *printf(L1i/) ∆i /' '>C ↑(i<Q1)100
**

*** вывод комплекса с отрицательными числами
sprint_complex(L1/)
	Oi
	§100 *sprintf(L1i/) ∆i /' '>C ↑(i<Q1)100
**

*** вывод отрицательного числа
*** 19.04.2016 ВНИМАНИЕ: не всегда работает правильно, например на ffffffffh
*** 26.10.2016 Внимание: диапазон значений чисел в таком представлении от -2 млрд до 2 млрд
*** для отрицательных чисел требуется сохранять значение последнего нуля,
*** и решить, как обрабатывать сдвиги например у 1111...11 = -1
*** при сдвиге вправо должен получиться 0 = 0000...00, но получится 1111...11 = -1
sprintf(x/)
	@+F1(100) OQ1
	x&I31⇒y x⇒t
	*** x&ffff0000h⇒y x⇒t
	*** ↑(y=0)1 x¬⇒t /'-'>C
	↑(y=0)1 0-x⇒t /'-'>C
	§1
		*n2s(t,10/F1)
		/F1>C
**



*** обернуть эту функцию в алгоритм поиска функции эйлера
*** количество взаимнопростых чисел из разложения числа работает в тандеме с trial_division_method
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** n - число для которого ищется функция эйлера
*** c - количество взаимнопростых
numbOfCoprimes(L1,n/c)
	1⇒c n⇒q Oi
	§1 L1i-1⇒b q/L1i⇒q c*b⇒c ∆i ↑(i≥Q1)2 →1 ***/'ef: b = '>C *printf(b/) /'\n'>C
	§2 q*c⇒c
**


*** ТРЕБУЕТСЯ ДОДЕЛАТЬ: пропускать числа из L1, которые уже были
*** количество взаимнопростых чисел из разложения числа работает в тандеме с trial_division_method_v2
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** c - количество взаимнопростых
numbOfCoprimes_v2(L1,n/c)
	1⇒c Oi
	§1 L1i-1⇒b c*b⇒c ∆i ↑(i≥Q1)2 →1 ***/'ef: b = '>C *printf(b/) /'\n'>C
	§2
**


*** **************************
*** Конец чего то
*** **************************

n(a/b) 
	a+'A'⇒b ↑(a<10)1 a-10+'A'⇒b
	§1
**

n2c(a/b) 
	a+'0'⇒b ↑(a<10)1 a-10+'A'⇒b 
	§1
** 


s2n(F1,q/a)
	Oi
	§1 ↑(i≥Q1)2
			F1i⇒c
			*c2n(c/b)
			a*q+b⇒a
			∆i →1
	§2 
**


decstrtoperem(F1/a)
	Oi
	F1i-'0'⇒a
	§1 ∆i ↑(i=Q1)3
	§2 a*10+F1i-'0'⇒a →1
	§3
**


genm(n,m/L1)
	32-n⇒k
	T;100⇒s
	Oj
	Oi
	§5 Oa
	§6 X ∆a
	§7 ↑(a<s)6
	§1 X>k⇒L1i ∆i ↑(i<m)5
	§3 m⇒Q1
**

*** Наибольший общий делитель
GCD(a,b/b)
	§1 OZ a:b⇒q b⇒a Z⇒b ↑(b>1)1
**




invertible_element_old(a, b/y, c)
	Of a⇒c b⇒d 0⇒y 1⇒w Os ↑(a≠0)1 1⇒y b⇒c →6
	§1	/'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2	∆s ↑(d=0)3 c/d⇒q *printf(d/) /'	'>C *printf(w/) /'	'>C *printf(q/) /'\n'>C
		q*d⇒r c-r⇒r q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3	↑(c≠1)5 s;2⇒f ↑(f>0)4 →6
	§4	↑(y=0)6 a-y⇒y →6
	§5	/'Error: Im sorry, but there is no invertible element GCD != 1\n'>C Oy Oc
	§6 /'\n'>C
**


*** в отличии от старого заменена операция деления с остатком на OZ c:d
invertible_element(a, b/y, c)
	Of a⇒c b⇒d 0⇒y 1⇒w Os ↑(a≠0)1 1⇒y b⇒c →6
	§1	*** /'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2	∆s ↑(d=0)3 OZ c:d⇒q Z⇒r *** *printf(d/) /'	'>C *printf(w/) /'	'>C *printf(q/) /'\n'>C
		q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3	↑(c≠1)5 s;2⇒f ↑(f>0)4 →6
	§4	↑(y=0)6 a-y⇒y →6
	§5	/'Error: Im sorry, but there is no invertible element GCD != 1\n'>C Oy Oc
	§6 *** /'\n'>C
**



*** Расширенный Алгоритм Евклида
*** x - a*x+b*y=c
*** y - a*x+b*y=c
*** c - наибольший общий делитель чисел a и b
*** f - признак отрицательности чисел x или y
*** f = 0 => x < 0
*** f = 1 => y < 0
*** a - входное число для GCD(a, b)
*** b - входное число для GCD(a, b)
Extended_Euclidean_Algorithm(a, b/x, y, c, f)
	Of⇒y+1⇒w a⇒c b⇒d ↑(a≠0)1 ∆y b⇒c →6
	§1 *** /'a	y	q'>C /'\n'>C *printf(c/) /'	'>C *printf(y/) /'\n'>C
	§2 ∆f;2⇒f ↑(d=0)3 OZ c:d⇒q Z⇒r *** *printf(d/) /'	'>C  *printf(w/) /'	'>C *printf(q/) /'\n'>C
		*** q*d⇒r c-r⇒r
		q*w⇒t y+t⇒y d⇒c r⇒d w⇒t y⇒w t⇒y →2
	§3
		/'f = '>C *printf(f/) /'\n'>C
		/'b = '>C *printf(b/) /'\n'>C
		/'y = '>C *printf(y/) /'\n'>C
		/'c = '>C *printf(c/) /'\n'>C
		/'a = '>C *printf(a/) /'\n'>C
		↑(f>0)5 b*y-c/a⇒x →6
	§5 b*y+c/a⇒x →6
	§6	*** /'\n'>C
**



 
*** 
*** q - система счисления
*** i - следующая пустая позиция
scanf(F1, i, q/a, i)
	***↑(Q1=0)5
	Oa 10⇒q
	↑(i≥Q1)5
	§1 ↑(i≥Q1)4	*** может быть ошибка
  		F1i⇒c
  		↑(c≠' ')2 ∆i →4
  §2
      *c2n(c/b) ***/'b='>C *printf(b/) /'\n'>C
      *** /'q='>C *printf(q/) /'\n'>C
      a*q+b⇒a  ***/'a='>C *printf(a/) /'\n'>C
      ∆i →1
	§5	/'ERROR: Пустой массив(scanf)\n'>C
  §4
**
 


printf(k/)
	@+F1(100)
	OQ1
	*n2s(k,10/F1)
	/F1>C
**




Hprintf(a/)
	@+F1(100)
	@'0x'>F1
	Oi 15⇒y Of
	§1 ↑(i≥8)4
			i+1*4⇒s
			16<1-s⇒s *** *printf(s/) /'\n'>C
			a>s⇒x x&y⇒x *** *printf(x/) /'\n'>C
			↑(x=0)2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'@>F1 →1
	§3 ∆i ↑(f=0)1 x+'0'@>F1 →1
	§4 ↑(Q1=2)5 /F1>C
	§5
**





n2s(a,q/F1) *** OZ a:q⇒a Z⇒b
	*** /'a = '>C *printf(a/) /'\n'>C *** что происходит?
	§1 a;q⇒b a/q⇒a b+'0'⇒c ↑(b<10)2 'A'+b-10@>F1 →3
	§2 c@>F1
	§3 a↦1 *pervec(F1/F1)
**


c2n(a/b)
	§1 a-'0'⇒b
		↑(b<10)2
		a-'A'+10⇒b
		↑(a<'Z')2
		a-'a'+10⇒b
	§2 
**




*** Дихотомический алг-тм возведения в степень числа
*** x - число возводимое в степень, y - степень этого числа, m - модуль
pow(x, y, m/z)
	Oj ∆j x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i *** /'j = '>C *printf(j/) /'\n'>C ∆j
		 ↑(i>y)5 OZ q*q:m Z⇒q *** /'q = '>C *Hprintf(q/) /'\n'>C
		 i&y↪3 OZ z*q:m Z⇒z *** /'z = '>C *Hprintf(z/) /'\n'>C
		 →3
	§5
**

pow_kostyl(x, y, m/z)
	@+L1(2)
	@+L2(2)
	@+L3(2)
	@+L4(4)
	x⇒L1.0 y⇒L2.0 m⇒L3.0 1⇒Q1⇒Q2⇒Q3
	*powBN(L1, L2, L3/L4)
	L4.0⇒z
**

*** наверное не работает, надо проверять 02.12.2015
pow1(x, y/L1)
	@+L2()
	@+L3()
	x⇒q 1⇒z⇒i y&1↪3 x⇒z
	§3 i<1⇒i ↑(i>y)5 q*q⇒q *** *printf(q/) /'\n'>C
		 i&y↪3 z*q⇒z *** *printf(z/) /'\n'>C
		 →3
	§5
**

pervec(F1/F1)
	Oi Q1-1⇒j
	§1 ↑(i≥j)2 F1i⇒t F1j⇒F1i t⇒F1j ∆i ∇j →1
	§2
**





*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
*** tdMeth(n/L2)
*** tridMeth(n/L2)
*** tdAlg(n/L2)
trial_division_method_v2(n/L2)
	@+L1(100)
	n⇒b
	Oj *countZeroes(n/s) *** /'s = '>C *printf(s/) /'\n'>C
	
	§9 ↑(s=j)8
		2⇒L2j ∆j →9
	§8
	100⇒Q1 *recalc_efficients(L1, 3/L1)
	
	↑(n<2)6 n>s⇒n
	*** n;2⇒k ↑(k=0)4 *** k↪4 одно и тоже с ↑(k=0)4, но не работает
	Oi *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 OZ n:L1i⇒q Z⇒r ↑(r≠0)4 *** n;L1i⇒r n/L1i⇒q ↑(r≠0)4
		*** /'n = '>C *printf(n/) /'\n'>C
		*** /'r = '>C *printf(r/) /'\n'>C
		*** /'q = '>C *printf(q/) /'\n'>C
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
	§3 L1i⇒L2j ∆j q⇒n →1
	§4 ↑(L1i≥q)5
		 ∆i ↑(i<Q1)2 Oi Q1-1⇒l *recalc_efficients(L1, L1l/L1) →1 *** возможно придётся i присваивать 1
	§5 n⇒L2j ∆j →7
	§6 /'ОШИБКА: Число должно быть больше 1\n'>C
	§7 b⇒n j⇒Q2
**


*** комплекс L1 - массив d - делителей числа
*** Комплекс L2 - массив сомножителей p
*** здесь j это t, а i это k
*** L3 - степени сомножителей
trial_division_method(n/L2, L3)
	
	@+L1(100)
	n⇒b
	Oj⇒f *countZeroes(n/s) *** /'s = '>C *printf(s/) /'\n'>C
	↑(s=0)8 2⇒L2j s⇒L3j ∆j OL3j
	§8
		100⇒Q1 *recalc_efficients(L1, 3/L1)
		↑(n<2)6 n>s⇒n *** /'n = '>C *printf(n/) /'\n'>C
	Oi *** возможно придётся i присваивать 1
	§1 ↑(n=1)7
	§2 OZ n:L1i⇒q Z⇒r ↑(r≠0)4 *** n;L1i⇒r n/L1i⇒q ↑(r≠0)4
		*** /'n = '>C *printf(n/) /'\n'>C /'r = '>C *printf(r/) /'\n'>C /'q = '>C *printf(q/) /'\n'>C
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
		1⇒f ∆L3j L1i⇒L2j q⇒n →1
	§4 ↑(L1i≥q)5
		∆i j+f⇒j Of⇒L3j ↑(i<Q1)2 Oi Q1-1⇒l *recalc_efficients(L1, L1l/L1) →1 *** возможно придётся i присваивать 1
	§5 j+f⇒j Of n⇒L2j ∆L3j ∆j →7
	§6 /'ОШИБКА: Число должно быть больше 1\n'>C →9
	§7 b⇒n j+f⇒Q2⇒Q3
	§9
**



*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method на маленьком числе
*** и большом числе, с условием, что большое число не предполагается делить на другое большое число
*** мощность комплекса всегда должна быть чётной
*** k - число - начало счёта последовательности
recalc_efficients(L1, k/L1)
	k⇒L1.0⇒l 2⇒d Oi+1⇒i
	§1 ↑(l≥5)2 l+d⇒L1i⇒l ∆i
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**


*** l - указывает на последнее обращённое число
*** функция используется в trial_division_method для маленьких чисел
recalc_efficients_v2(L1/L1)
	*** Q1⇒t t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	Q1⇒t-1⇒l t;2⇒t L1l⇒l 4⇒d Oi
	↑(t≠0)2
	§1 2⇒d
	§2 l+d⇒L1i⇒l ∆i d;4+2⇒d ↑(i<Q1)2 *** Oi
	§3 *** *printf(L1i/) /' '>C ∆i ↑(i<Q1)3 /'\n'>C
**



*** Тест Миллера-Рабина
*** возвращает значение b равное 1, если вероятно простое, 0, если составное
*** выбран вариант роста a на двойку после 3ёх: 2, 3, 5, 7,....
*** также можно добавить вариант со случайным значением a он закомментирован ниже
*** n - проверяемое число, r - количество раундов
miral(n, r/b)
	*** @+L1(20)
	*** @+L2(20)
	*** @+L3(20)
	*** OQ1⇒Q2 ***⇒Q3
	n-1⇒m Oq⇒s⇒b ∆q
	↑(n=1)5
	*countZeroes(m/s) *** на этой строке считается s - степень двойки (2^s)*t+1
	q<s⇒q m/q⇒t
	*** /'q = '>C *printf(q/) /'\n'>C
	Oi⇒j⇒c ∆c 2⇒a
	§1 ↑(i≥r)4 ↑(a≥m)4
		*** m-1⇒a X;a⇒a ↑(a<2)1 *** поиск псевдослучайного значения от 2 до n-2
		*pow(a, t, n/x)
		*** /'a = '>C *printf(a/) /'\n'>C
		∆i a+c⇒a 2⇒c
		↑(x=1)1 ↑(x=m)1 1⇒j
	§2 ↑(j≥s)5
		 *** x⇒L1.0 n⇒L2.0 1⇒Q1⇒Q2
		 *** /'x = '>C *printf(x/) /'\n'>C
		 *** *pow(x, 2, n/x)
		 x*x:n Z⇒x
		 *** L1*L1;L2⇒L1 L1.0⇒x
		 ↑(x=1)5 ↑(x=m)1 ∆j →2
	§4 ∆b *** /'Вероятно простое\n'>C *** иначе составное
	§5
**

*** формирует простое число из k бит
randPrime(k/t)
	↑(k<2)3 ↑(k>32)3
	§1
		 32-k⇒t k-1⇒c
		 X>t∨1∨Ic⇒t
		 *** /'t = '>C *printf(t/) /'\n'>C
		 *miral(t, 5/b) *** /'b = '>C *printf(b/) /'\n'>C
		 b↪1
	§3
**


*** формирует список простых чисел в которых k бит
randPrimesList(k, l/L1)
	Oi⇒Q1 ↑(k<2)3 ↑(k>32)3
	§1
		 32-k⇒t k-1⇒c
		 X>t∨1∨Ic⇒t
		 *** /'t = '>C *printf(t/) /'\n'>C
		 *miral(t, 5/b) *** /'b = '>C *printf(b/) /'\n'>C
		 b↪2 *** ↑(b=0)2
		 t⇒L1i ∆i i⇒Q1 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
	§2 ↑(i=l)3 →1
	§3
**

countZeroes(x/s)
	Os ↑(x=0)2 1⇒t t&x⇒a
	§1 ↑(a≠0)2 ∆s t<1⇒t t&x⇒a →1
	§2
**



*** Поиск первообразного корня
*** m - модуль
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** r - первообразный корень
primroot(m/r)
	Or
	@+L1(100)
	@+L2(100)
	*** @+L3(100)
	m-1=n *trial_division_method(n/L1,L2) 1=r *** *printf(n/) /' '>C *print_trtr(L1,L2/) /'\n'>C
	P1 r+1=r Oj *** *printf(r/) /'\n'>C
		P2 n/L1j=d *pow(r,d,m/b)
			 *** /'j = '>C *printf(j/) /'\n'>C
			 ?(b=1)1 Dj ?(j>=Q1)4 ?=2
	P4
**


*** Поиск первообразных корней
*** m - модуль
*** L1 - разложение числа на простые сомножители (функция эйлера)
*** r - первообразный корень
primroots(m/L2)
	@+L1(100)
	OQ2=i m-1=n *trial_division_method(n/L1,L2) 1=r *** *printf(n/) /' '>C *print_trtr(L1,L2/) /'\n'>C
	*numbOfCoprimes(L1,n/f) f;100=f *** /'f = '>C *printf(f/) /'\n'>C
	P1 r+1=r Oj *** *printf(r/) /'\n'>C
		P2 n/L1j=d *pow(r,d,m/b)
			 *** /'b = '>C *printf(b/) /'\n'>C
			 ?(b=1)1 Dj ?(j>=Q1)3 ?=2
			P3 r=L2i Yf Di=Q2 ?(f=0)4 ?=1
	P4 *** *print_complex(L2/)
**


*****************************************************************
***************	Алгоритмы над большими числами	*****************
*****************************************************************



div_mul_test(L1, L2/L3)
	@+L4(100)
	L1⇒L3⇒L4
	L1/L2 *** *HprintfBN(L4/)
	L4;L2 *** *HprintfBN(L3/)
	L1*L2+L4 *** *HprintfBN(L3/)
**

*** генерация случайного значения
*** randBN(L1/)
randBN(L1/)
	Q1⇒i X
	§1 i↪2 ∇i X⇒L1i →1
	§2
**



*** ввод большого числа [Добавить обработку нуля!!!]
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
*** big_int_input(L2, F1, i/L2, k) - старое название
inputBN(L2, F1, i/L2, k)
	@+F3(1)
	Oj⇒l⇒s *** /F1>C
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	*** /'i= '>C *printf(i/) /'\n'>C
	↑(F1i≠'0')7 ∆i ↑(F1i≠'x')7 ∆i⇒l⇒e
	*** /'e= '>C *printf(e/) /'\n'>C
	
	§10 ↑(l=Q1)11 ↑(F1l=32)11 ↑(F1l=10)11 ∆l
	*** /'l = '>C *printf(l/) /'\n'>C
	→10
	§11 l⇒k-1⇒i i-e+1/8⇒Q2 i-e+1;8⇒t ∆k Ol OL2l ↑(t=0)1 Q2+1⇒Q2
	§1
		1⇒Q3 F1i⇒F3.0 /F3>C
		*** *printf(i/) /' '>C
		↑(F1i<48)7 ↑(F1i>57)2 F1i-'0'⇒x →4
	§2
		↑(F1i<65)7 ↑(F1i>70)3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<97)7 ↑(F1i>102)7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<e)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное. Возможно не хватает 0x вначале\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 *cutZerosBN(L2/L2)
**


*** ввод большого числа 2ой вариант [Добавить обработку нуля!!!]
*** одна строка - одно число
*** k может вернуться больше размерности комплекса F1 => алгоритм не сработает, необходимо проверять в программе, что размер числа > 0
*** big_int_input(L2, F1, i/L2, k) - старое название
inputBN_2(L2, F1/L2)
	Oj Ol Os
	*** первая проверка может быть лишняя из-за 8го парраграфа
	↑(Q1=0)6 ↑(i≥Q1)8
	↑(F1.0≠'0')7 ↑(F1.1≠'x')7
	
	Q1-1⇒i-1/8⇒Q2 OL2l
	*** /'i = '>C *printf(i/) /'\n'>C
	*** /'Q2 = '>C *printf(Q2/) /'\n'>C
	i-1;8↪1 Q2+1⇒Q2
	§1
			*** GLITCH не сработало сравнение ?(F1i>'9')#
		↑(F1i<48)7 ↑(F1i>57)2 F1i-'0'⇒x →4
	§2
		↑(F1i<65)7 ↑(F1i>70)3 F1i-'A'+10⇒x →4
	§3
		↑(F1i<97)7 ↑(F1i>102)7 F1i-'a'+10⇒x
	§4
		x<s⇒x s+4⇒s L2l∨x⇒L2l ∇i ↑(i<2)9 ∆j ↑(j≥8)5 →1
	§5
		∆l OL2l⇒s⇒j →1
	§6
		/'ОШИБКА: Символьный комплекс пустой\n'>C →9
	§7
		/'ОШИБКА: Число не шестнадцатеричное. Возможно не хватает 0x вначале\n'>C OQ2 →9
	§8
		/'ОШИБКА: Символьный комплекс закончился.\n'>C OQ2
	§9 *cutZerosBN(L2/L2)
**






*** вывод большого числа в шестнадцатеричном виде
*** 0x0 будет выводиться только если мощность комплекса Q равна 1
*** если там будет больше элементов и все будут нули, то на выходе получится "0x"
*** закомментированные окончания строк 352, 353, 355 убраны и добавлена переменная l для избежания ситуации выше с 0x, теперь если большое число равно 0, то на выходе будет 0x0 2=>l здесь для затирания 0, если число не равно ему
*** printHexBN(L1/)
*** printHBN(L1/)
*** printhBN(L1/)
*** HprintfBN(L1/)
HprintfBN(L1/)
	@+F2(100)
	↑(Q1=0)7
	Oi⇒f 4⇒s Q1-1⇒j 15⇒y '0'@>F2 'x'@>F2 '0'@>F2 2⇒l+1⇒Q2
	§1 ↑(i≥8)4
			***/'j= '>C *printf(j/) /'\n'>C
			16<1-s⇒t ***/'t= '>C *printf(t/) /'\n'>C	*** 16 для оптимизации под конкретную архитектуру
			L1j>t⇒x x&y⇒x s+4⇒s *** /'x= '>C *printf(x/) /'\n'>C
			*** *Hprintf(L1j/)
			x↪2 1⇒f
	§2 ↑(x<10)3 ∆i x-10+'A'⇒F2l ∆l⇒Q2 →1 *** ∆l⇒Q2 для того, чтобы обрабатывался ноль, как 0x0
	§3 ∆i ↑(f=0)1 x+'0'⇒F2l ∆l⇒Q2 →1 *** связано с 2⇒l+1⇒Q2
	§4 ↑(j=0)5 4⇒s ∇j Oi →1 *** ↑(j≥Q1)5
	§5 ↑(Q1>1)6 *** ↑(L1.0>0)6 '0'@>F2
	§6 /F2>C
	§7
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3*2⇒l *optimize(L5, l/L5)
	§1
		↑(i≥32)3 Ii&L2j↪2
		*** /'#############\n'>C
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L5= '>C *HprintfBN(L5/) /'\n'>C
		*** /'#############\n'>C
		L5*L6;L3⇒L6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'Q6 = '>C *printf(Q6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n'>C
		
		*** L6;L3⇒L6 *** /'33\n'>C *** Q3⇒Q6
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	   
	§2
		L5*L5;L3⇒L5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	   *** /'Q5 = '>C *printf(Q5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом баррета взятия по модулю
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_bar(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	@+L7(1000)
	
	Q3*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L3⇒L7 *** L7 = z
	
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	*** L1;L3=L5 не заменяется на barmod(...)
	L1;L3⇒L5 Q3*2⇒l
	§1
		↑(i≥32)3 *optimize(L5, l/L5) *** в barmod обрезается мощность и без этого не работает
		Ii&L2j↪2 *** Q5+Q6⇒l *optimize(L6, l/L6)
		L5*L6⇒L6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'11\n'>C
		*barmod(L6, L3, L7/L6) *** Q3⇒Q6
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		 L5*L5⇒L5
		 *barmod(L5, L3, L7/L5) *** Q3⇒Q5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом Карацубы
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_karat(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3+Q3⇒l *optimize(L6, l/L6) *optimize(L5, l/L5)
	§1
		↑(i≥32)3 Ii&L2j↪2
		*** /'#############\n'>C
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'L5= '>C *HprintfBN(L5/) /'\n'>C
		*** /'#############\n'>C
		*karatsuba(L5, L6/L6)
		*** /'L6= '>C *HprintfBN(L6/) /'\n'>C
		*** /'Q6 = '>C *printf(Q6/) /'\n'>C
		*** /'L3= '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n'>C
		L6;L3⇒L6 Q3⇒Q6
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		*karatsuba(L5, L5/L5) L5;L3⇒L5 Q3⇒Q5
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	   *** /'Q5 = '>C *printf(Q5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**


*** Дихотомический алг-тм возведения в степень с методом Карацубы и методом баррета взятия по модулю
*** L1 - число возводимое в степень, L2 - степень этого числа, L3 - модуль
*** L5 - q, L4 - z
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN_mix(L1, L2, L3/L4)
	@+L5(1000)
	@+L6(1000)
	@+L7(1000)
	
	Q3*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L3⇒L7 *** L7 = z
	
	1⇒Q6⇒Q5⇒L6.0 Oj⇒i
	L1;L3⇒L5 Q3+Q3⇒l *optimize(L6, l/L6) *optimize(L5, l/L5)
	§1
		 ↑(i≥32)3 Ii&L2j↪2
		 *karatsuba(L5, L6/L6) *barmod(L6, L3, L7/L6)
	   *** /'L6= '>C *HprintfBN(L6/) /'\n'>C
	§2
		 *karatsuba(L5, L5/L5) *barmod(L5, L3, L7/L5)
	   *** /'L5= '>C *HprintfBN(L5/) /'\n'>C
	 ∆i →1
	§3 ∆j ↑(j≥Q2)4 Oi →1
	§4 Q6⇒Q4 L6⇒L4
		 *cutZerosBN(L4/L4)
**



*** /'d L4= '>C *HprintfBN(L4/)
*** /'Q4= '>C *printf(Q4/) /' '>C
*** /'d L5= '>C *HprintfBN(L5/)


optimize(L1, n/L1)
	Q1⇒i n⇒Q1
	§1 ↑(i≥n)2 OL1i ∆i →1
	§2 
**

*** Метод пробных делений на больших числах
*** на входе всегда нечётное число
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** L9 - степени сомножителей
*** s -  степень числа
*** /'Q2 = '>C *printf(Q2/) /'\n'>C
*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
tdmBN(L1/L3, L4, L9)
	@+L7(100) ***(Q1)
	@+L2(100)
	@+L5(100)
	Q1⇒Q7 L1⇒L7 Oj⇒f
	*countZeroesBN(L1/s)
	↑(s=0)11 2⇒L3j s⇒L9j ∆j OL9j
	§11 Of  L1>s⇒L1 *cutZerosBN(L1/L1)
		 ↑(Q1>1)8 L1.0⇒n *trial_division_method(n/L2, L5) Oi
	§12
		 ↑(i≥Q2)9 L2i⇒L3i L5i⇒L9i ∆i-1⇒j+1⇒Q9⇒Q3 →12
	§8
		 @+L6(1)
		 100⇒Q2 *recalc_efficients(L2, 3/L2) 1⇒Q4⇒Q5⇒Q6 OQ3 3⇒L6.0
		 *BN_less(L7, L6/b) ↑(b=1)6
		 Oi *** возможно придётся i присваивать 1
	§1 1⇒L6.0 *BN_eq(L1, L6/b)
		 ↑(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	§2 ↑(L2i<3)10 L2i⇒L6.0
		 L1/L6⇒L4 L1;L6⇒L5 *cutZerosBN(L4/L4) *cutZerosBN(L5/L5) OL6
	*** ↑(L2i<145900)3 /'L2i = '>C *printf(L2i/) /'\n'>C /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	*** §3	 
		 *BN_neq(L5, L6/b) ↑(b≠0)4
		 1⇒f ∆L9j L2i⇒L3j Q4⇒Q1 L4⇒L1 →1
	§4 L2i⇒L6.0
		 *BN_greq(L6, L4/b)
		 ↑(b=1)5
		∆i j+f⇒j Of⇒L9j ↑(i<Q2)2 Oi Q2-1⇒l *recalc_efficients(L2, L2l/L2)
		→1 *** возможно придётся i присваивать 1
	§5 ↑(Q1>1)13 j+f⇒j Of L1.0⇒L3j ∆L9j ∆j OL4 OQ4 →9
	§13
		 Q1⇒Q4 L1⇒L4 *cutZerosBN(L4/L4) →9
	§6 /'Число должно быть больше 2'>C
	§10 /'unsigned int числа закончились\n'>C
	§9 j+f⇒Q3⇒Q9 Q7⇒Q1 L7⇒L1
**


*** Метод пробных делений на больших числах без комплекса степеней чисел
*** комплекс L1 - большое число
*** комплекс L2 - массив d - делителей числа
*** Комплекс L3 - массив сомножителей p
*** Комплекс L4 - представление делителя из массива L2 большим числом
*** здесь j это t, а i это k
*** все сравнения BN_*(*/?) делаются без учёта мощностей комплексов(больших чисел), потому что результаты арифметических операций над ними не возвращают новую мощность результата 08.12.2015
*** s -  степень числа
*** ndc - no degrees complex
tdmBN_ndc(L1/L3, L4)
	@+L7(100) ***(Q1)
	@+L2(100)
	*countZeroesBN(L1/s) s⇒t
	Q1⇒Q7 L1⇒L7 *cutZerosBN(L1/L1)
	§12 ↑(t=0)11 2⇒L3j ∆j ∇t →12
	§11 
		 ↑(Q1>1)8 L1.0⇒n *trial_division_method(n/L2) Oi
	§13
		 ↑(i≥Q2)9 L2i⇒L3j ∆i ∆j⇒Q3 →13
	§8
		 @+L5(100)
		 @+L6(1)
		 
		 100⇒Q2 *recalcefficients(L2, 3/L2) 1⇒Q4⇒Q5⇒Q6 OQ3
		 3⇒L6.0
		 *BN_less(L1, L6/b) ↑(b=1)6 L1>s⇒L1 *cutZerosBN(L1/L1)
		 Oi *** возможно придётся i присваивать 1
	§1 1⇒L6.0 *BN_eq(L4, L6/b)
		 ↑(b=1)9
		 *** проверка может не пройти, если в комплексе лежит 1, но мощность комплекса больше 1
	§2 ↑(L2i<3)10 L2i⇒L6.0
		 L1;L6⇒L5 *cutZerosBN(L5/L5) L1/L6⇒L4 *cutZerosBN(L4/L4) OL6
		 *BN_neq(L5, L6/b)
		 ↑(b≠0)4
		 *** Возможна ошибка, если мощность комплекса больше 1, но число равно 0
		 L2i⇒L3j
		 ∆j L4⇒L1 →1
	§4 L2i⇒L6.0
		 *** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		 *BN_greq(L6, L4/b)
		 ↑(b=1)5
		∆i ↑(i<Q2)2 Oi Q2-1⇒l *recalcefficients(L2, L2l/L2)
		*** *printf(L2.0/) /'\n'>C *printf(L2.1/) /'\n'>C *printf(L2.2/) /'\n'>C *printf(L2.3/) /'\n'>C
		→1 *** возможно придётся i присваивать 1
	§5 ↑(Q1>1)14 L1.0⇒L3j ∆j OQ4 →9
	§14
		 Q1⇒Q4 L1⇒L4 *cutZerosBN(L4/L4)
		 *** /'Q1 = '>C *Hprintf(Q4/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L4/) /'\n'>C
		 →9
	§6 /'Число должно быть больше 2'>C
	§10 /'unsigned int числа закончились\n'>C
	§9 j⇒Q3⇒Q9 Q7⇒Q1 L7⇒L1
		 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
		 *** /'Q7 = '>C *printf(Q7/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 *** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
**



*** функция сжимает большое число - уменьшает его мощность, если впереди есть нулевые элементы
*** применяется после арифметических операций, где возможно уменьшение мощности числа, но сами арифметические операции его не уменьшают 08.12.2015
cutZerosBN(L1/L1)
	Q1-1⇒i
	§1 ↑(L1i≠0)2 ↑(i=0)2 i⇒Q1 ∇i →1
	§2
**


*** Дихотомический алг-тм возведения в небольшую степень большого числа
*** L1 - число возводимое в степень, y - степень этого числа, L2 - модуль
*** думаю в нём нет смысла, если использовать метод из pow(), можно убрать модуль, тогда получится большое число в степени "маленького" числа
powBN1(L1, y, L2/L4)
	*** @+L4(100)
	@+L3(100)
	
	1⇒Q4⇒Q5
	L1⇒L3 Q2+Q2⇒l *optimize(L3, l/L3) *optimize(L4, l/L4) 1⇒L4.0⇒i
	y&1↪3 L1⇒L4 *optimize(L4, l/L4)
	§3 i<1⇒i ↑(i>y)5 L3*L3;L2⇒L3
		 *** /'Q5= '>C *printf(Q5/) /'\n'>C
		 i&y↪3 L3*L4;L2⇒L4
		 *** /'L4= '>C *HprintfBN(L4/) /'\n'>C
		 →3
	§5
**


*** Дихотомический алг-тм возведения в степень
*** L1 - число возводимое в степень, L2 - степень этого числа
*** L4 - q, L3 - z 
*** 01.11.2015 операции над большими числами не изменяют мощность комплексов
powBN2(L1, L2/L3)
	@+L4(100)
	
	1⇒Q4⇒Q5 Oj
	L1⇒L4 Q3+Q3⇒l *optimize(L4, l/L4) *optimize(L3, l/L3) 1⇒L3.0⇒i⇒s i<1⇒i L2j&1↪1 L1⇒L3 *optimize(L3, l/L3)
	§1 ↑(s≥32)3 L4*L4⇒L4
	   *** /'L4= '>C *HprintfBN(L4/)
		 i&L2j↪2 L4*L3⇒L3
	   *** /'L3= '>C *HprintfBN(L3/)
	§2 ∆s i<1⇒i →1
	§3 ∆j ↑(j≥Q2)4 Os 1⇒i →1
	§4 *cutZerosBN(L3/L3)
**

*** возможно ли, что степень двойки будет большим числом?
*** проблема - может прийти комплекс с мощностью больше 1, но равный нулю
countZeroesBN(L1/s)
	↑(Q1=0)4 Oi⇒s ↑(Q1>1)1 ↑(L1.0=0)5
	§1 ↑(i≥Q1)3 ↑(L1i≠0)2 s+32⇒s ∆i →1
	§2 *countZeroes(L1i/b) *** /'czs = '>C *printf(s/) /'\n'>C
		 *** /'b = '>C *printf(b/) /'\n'>C
		 s+b⇒s
		 *** /'s = '>C *printf(s/) /'\n'>C
		 *** /'i = '>C *printf(i/) /'\n'>C
	§3 s/Q1⇒t s;Q1⇒l t+l⇒l ↑(l=32)5 →6
	§4 /'ОШИБКА: Мощность комплекса равна нулю\n'>C
	§5 Os /'ОШИБКА: Комплекс полностью из нулей\n'>C
	§6
**


*** генерация простого числа
*** k - количество бит
*** l - максимально возможная длина числа (количество элементов)
*** L1 - число
randPrimeBN(k/L1)
	Oi⇒Q1⇒s⇒t ↑(k<2)4
	§1 OZ k:32⇒t Z⇒s
		31⇒c ↑(s=0)2 s-1⇒c ∆t
	§2
		↑(t>S1)4 t⇒Q1 Is-1⇒s ↑(s>0)3 ffffffffh⇒s
	§3
		*randBN(L1/)
		*** /'t = '>C *printf(t/) /'\n'>C
		 Q1-1⇒t
		 *** /'rBN s = '>C *printf(s/) /'\n'>C
		 *** /'begin c = '>C *printf(c/) /'\n'>C
		 *** /'t = '>C *printf(t/) /'\n'>C
		 L1.0∨1⇒L1.0 L1t∨Ic⇒L1t s&L1t⇒L1t
		 *** /'Current Number: '>C *HprintfBN(L1/) /'\n'>C
		 *miralBN(L1, 5/b)
		 *** /'b = '>C *printf(b/) /'\n'>C
		  b↪3 *** ↑(b=0)3
	§4 *** /'Q1 = '>C *printf(Q1/) /'\n'>C
**

*** miller-rabin-algorithm()
*** r - количество раундов, есть ли смысл делать большим числом?
*** может ли степень s быть больше 32 бит?
*** L1 - n простое нечётное число
*** 
*** 
*** 
*** 
miralBN(L1, r/b)
	Q1*2⇒n
	@+L3(n) *** m ⇒ n-1 (L1-1)
	@+L4(n) *** q, потом t n ⇒ (q^2)*t+1
	*** @+L5(20) *** t
	@+L6(n) *** i, до начала индексации промежуточный комплекс
	@+L7(n) *** a
	@+L8(n) *** 1ца, 2ка для последовательности 2, 3, 5 ,7,...
	*** @+L9(20) *** 
	@+L10(n) *** x
	*** @+L11(20) *** j на случай, если степень двойки(число s) будет большим числом
	
	1⇒L4.0⇒Q6⇒Q4⇒Q3 Ob
	*BN_eq(L1, L3/c) ↑(c=1)5
	Q1⇒Q3 OL3 1⇒L3.0
	L1-L3⇒L3 *** L3 теперь m ⇒ n-1 (L1-1)
	*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
	*countZeroesBN(L3/s)
	L4<s⇒L4
	*** /'s = '>C *printf(s/) /'\n'>C
	*** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
	L3/L4⇒L4
	Oj⇒i 1⇒L8.0⇒L6.0 2⇒L7.0 1⇒Q7⇒Q8⇒Q6
	§1 ↑(i≥r)4 *BN_greq(L7, L3/c) ↑(c=1)4
		 *** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		 *** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
		 *** /'L4 = '>C *HprintfBN(L4/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 *powBN(L7, L4, L1/L10)
		 *** /'L10 = '>C *HprintfBN(L10/) /'\n'>C
		 ∆i L7+L8⇒L7 1⇒L8.0
		 *** /'L7^L4 mod L1 = '>C *HprintfBN(L10/) /'\n'>C
		 **** /'L8 = '>C *HprintfBN(L8/) /'\n'>C
		 *** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
		 
		 *BN_eq(L10, L8/c) 2⇒L8.0 ↑(c=1)1
		 *BN_eq(L10, L3/c) ↑(c=1)1
		 1⇒j
	§2 ↑(j≥s)5
		 *** /'L10 = '>C *HprintfBN(L10/) /'\n'>C
		 *** /'L8 = '>C *HprintfBN(L8/) /'\n'>C
		 *** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		 L10*L10;L1⇒L10 1⇒L8.0
		 *** 2⇒L8.0 *powBN(L10, L8, L1/L10) 1⇒L8.0
		 *** /'L10^L8 mod L1 = '>C *HprintfBN(L10/) /'\n'>C
		 *BN_eq(L10, L8/c) 2⇒L8.0 ↑(c=1)5 *BN_eq(L10, L3/c) ↑(c=1)1 ∆j →2
	§4 ∆b *** /'Вероятно простое\n'>C
	§5
**


*** возможно ли, что степень двойки будет большим числом?
*** проблема - может прийти комплекс с мощностью больше 1, но равный нулю
countZeroesBN(L1/s)
	↑(Q1=0)4 Oi⇒s ↑(Q1>1)1 ↑(L1.0=0)5
	§1 ↑(i≥Q1)3 ↑(L1i≠0)2 s+32⇒s ∆i →1
	§2 *countZeroes(L1i/b) *** /'czs = '>C *printf(s/) /'\n'>C
		 *** /'b = '>C *printf(b/) /'\n'>C
		 s+b⇒s
		 *** /'s = '>C *printf(s/) /'\n'>C
		 *** /'i = '>C *printf(i/) /'\n'>C
	§3 s/Q1⇒t s;Q1⇒l t+l⇒l ↑(l=32)5 →6
	§4 /'ОШИБКА: Мощность комплекса равна нулю\n'>C
	§5 Os /'ОШИБКА: Комплекс полностью из нулей\n'>C
	§6
**


*** Алгоритм карацубы перемножения 2ух больших чисел
*** http://samos-it.com/posts/recursive-karatsuba-multiplication-python.html
*** f - признак нулевого комплекса - требуется восстановить значение 0
karatsuba(L1, L2/L3)
	@+L4(1000) *** 1ая половина L1 b
	@+L5(1000) *** 2ая половина L1 a
	@+L6(1000) *** 1ая половина L2 d
	@+L7(1000) *** 2ая половина L2 c
	@+L8(1000) *** результат первых половин ab
	@+L9(1000) *** результат вторых половин cd
	@+L11(1000)
	@+L12(1000)
	
	Q1⇒Q11 L1⇒L11 Q2⇒Q12 L2⇒L12
	
	*** Q2 сравнивается со старым значением Q1 (t)
	*** мощность одного из комплексов увеличивается до максимума n
	Q12⇒n/2⇒w ↑(Q12=Q11)2 ↑(Q12>Q11)1 Q11⇒n/2⇒w *optimize(L12, n/L12) →2
	§1
		*optimize(L11, n/L11)
	§2
		↑(n>50)3
		n*2⇒Q3 OL3 1⇒L3.0 L3*L11*L12⇒L3 *cutZerosBN(L3/L3) →8
	
	§3
		n;2↪4 n⇒t+1⇒Q11⇒Q12⇒n/2⇒w OL12t OL11t
	§4
		L11⇒L5 Q11-w⇒Q5⇒Q4-1⇒t OL4t Q11-w*32⇒t L11>t⇒L4 w⇒Q4
		L12⇒L7 Q12-w⇒Q7⇒Q6-1⇒t OL6t Q12-w*32⇒t L12>t⇒L6 w⇒Q6
		*karatsuba(L4, L6/L8) *** A
		*karatsuba(L5, L7/L9) *** B
		*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
		Q4⇒t+1⇒Q4 OL4t
		Q6⇒t+1⇒Q6 OL6t
		L4+L5⇒L4 L6+L7⇒L6
		Q4-1⇒t ↑(L4t>0)5 t⇒Q4
	§5
		Q6-1⇒t ↑(L6t>0)6 t⇒Q6
	§6
		*karatsuba(L4, L6/L3) *** C
		*** /'L3 = '>C *HprintfBN(L3/) /'\n'>C
		*** /'Q3 = '>C *printf(Q3/) /'\n\n'>C
		Q3⇒t+w⇒Q3 OL3t
		w⇒q<5⇒t
		L3-L8-L9⇒L3
		L3<t⇒L3
		32*n⇒t n+Q8⇒Q8 L8<t⇒L8
		*** Здесь возможна ситуация, когда мощность L3
		*** больше L8, тогда требуется к L3 добавить
		*** содержимое двух комплексов L8 и L9
		*** иначе(Q8>Q3) к L8 добавить L3 и L9
		↑(Q8>Q3)7 L3+L8+L9⇒L3 →8
		*** Q3⇒l *optimize(L8, l/L8)
	§7
		L8+L3+L9⇒L3
	§8
**




*** Алгоритм баррета приведения числа по модулю
*** L1 - x число
*** L2 - m модуль
***
***
*** L3 - z
*** L3 = [(b^2k)/L2] ~ z = [(b^2k)/m]
*** Q2*2⇒Q3 OL3
*** Q3⇒k+1⇒Q3 1⇒L3k L3/L2⇒L3
*** 
*** Q2*2⇒Q3 OL3
*** Q3⇒k+1⇒Q3 1⇒L3k L3/L2⇒L3 *** L3 = z
*** L4 - q, r2, r(результат)
*** base ⇒ 2^32 ⇒ 0x100000000
barmod(L1, L2, L3/L4)
	*** /'		Barret\n'>C
	*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
	*** /'L2 = '>C *HprintfBN(L2/) /'\n'>C
	*** /'L3(z) = '>C *HprintfBN(L3/) /'\n'>C
	
	*** 32=b
	@+L5(1000) *** r1
	@+L6(1000) *** r'
	@+L7(1000)
	
	*** Если b = 0x100000000 тогда b^2k = 1^(2*(k+1)*32)?
	
	
	
	Q2-1*32⇒k *** /'k = '>C *printf(k/) /'\n'>C
	Q2+1*32⇒t *** /'t = '>C *printf(t/) /'\n'>C
	*** /'			L1 = '>C *HprintfBN(L1/) /'\n'>C
	L1>k⇒L7 Q7+Q3⇒l *optimize(L7, l/L7) L7*L3⇒L7 L7>t⇒L7 *** L7 = q
	*** /'Q7 = '>C *printf(Q7/) /'\n'>C
	*** /'L7(q`) = '>C *HprintfBN(L7/) /'\n'>C
	*** /'r1 = '>C
	L1⇒L5 Q2+1⇒Q5 *** *HprintfBN(L5/) /'\n'>C *** L5 = r1
	*** /'r2 = '>C
	L7*L2⇒L7 Q2+1⇒Q7 *** *HprintfBN(L7/) /'\n'>C *** L7 = r2
	*** /'Q7 = '>C *printf(Q7/) /'\n'>C
	*** /'Q5 = '>C *printf(Q5/) /'\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
	*** /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	
	*** GLITCH: в Q5 оказалось значение Q1
	
	
	
	*** /'L5(r1) = '>C *HprintfBN(L5/) /'\n'>C
	*** /'L7(r2) = '>C *HprintfBN(L7/) /'\n'>C
	*** /'L6(r`) = '>C *HprintfBN(L6/) /'\n'>C
	
	
	*BN_greq(L5, L7/c) ↑(c=0)1 L5-L7⇒L6 →2
	§1
		L5+L6-L7⇒L6
	§2
		*** /'bar L6 = '>C *HprintfBN(L6/) /'\n'>C
		*cutZerosBN(L6/L6) *BN_greq(L6, L2/c)
		↑(c=0)3 L6-L2⇒L6 →2
	§3
		*** /'L6 = '>C *HprintfBN(L6/) /'\n'>C
		Q6⇒Q4 L6⇒L4 *** L7 = r(результат)
	
	
	*** *Hprintf(L1.0/) /'\n'>C
	*** *Hprintf(L2.0/) /'\n'>C
	*** /'k = '>C *printf(k/) /'\n'>C
	*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n'>C
**




*** проверка, что 2 больших числа равны
BN_eq(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что большое число L1 больше числа L2
BN_gr(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆b ↑(L2i<L1i)2 Ob ∆i ↑(i<n)1
	§2
**

*** проверка, что большое число L1 меньше числа L2
BN_less(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob
	§1 ↑(L1i>L2i)2 ∆b ↑(L2i>L1i)2 Ob ∆i ↑(i<Q1)1
	§2
**

*** проверка, что большое число L1 больше ил равно числу L2
BN_greq_old(L1, L2/b)
	Ob⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i<L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**


*** проверка, что большое число L1 больше ил равно числу L2
BN_greq(L1, L2/b)
	Ob Q1-1⇒i
	↑(Q1<Q2)2 ∆b ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	§1 ∆b ↑(L1i>L2i)2 Ob ↑(L1i<L2i)2 ∇i ↑(i<Q1)1 ∆b
	§2
**


*** проверка, что большое число L1 меньше или равно числу L2
BN_leq(L1, L2/b)
	Ob⇒i
	↑(Q1>Q2)2 ∆b ↑(Q2>Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Ob Q1⇒n
	§1 ↑(L1i>L2i)2 ∆i ↑(i<n)1 ∆b
	§2
**

*** проверка, что 2 больших числа не равны
BN_neq(L1, L2/b)
	Ob⇒i ∆b
	↑(Q1<Q2)2 ↑(Q2<Q1)2 *** раскомментировать
	*** закомментировано, потому что результаты операций не возвращают новую мощность 08.12.2015
	Q1⇒n
	§1 ↑(L1i≠L2i)2 ∆i ↑(i<n)1 Ob
	§2
**



**************************************************************************************
****************	Алгоритмы над большими числами закончились	****************
**************************************************************************************



**************************************************************************
*****************	Алгоритмы над булевыми функциями ****************
**************************************************************************

*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1, L2/L2)
	Oj Q1-1⇒i Q1⇒L2.0-1⇒n ∆j OL2j
	§1 F1i-48↦2 L2j<1⇒L2j ∇i →3
	§2 L2j∨1<1⇒L2j ∇i
	§3 ↑(i=0)5 →1
	§4 ∆j OL2j →1
	§5
**

*** 
*** n - размер булевой функции
*** вывод булевой функции
BFoutput(L1/)
	@+F2(1)
	1⇒i⇒Q2 Oz⇒c L1.0⇒n
	§1 1<z⇒t L1i&t>z+48⇒F2.0 ∆c
		 /F2>C /'\n'>C
		 ∆z ↑(z=31)2 ↑(c=n)3 →1
	§2 Oz ∆i ↑(i=Q1)3 →1
	§3
**


*************************************************
******* 	Надо сделать красивее_begin	 ********
*************************************************

main_boolfuncs(/)
	
	
	
	*** *bool_input_output_weight_test(/)
	*** *bool_rand_test(/)
	*** *bool_moebius_test(/)
	*** *bool_pua_test(/)
	*** *test_printANF(/)
	*** *test_degree(/)
	*** *test_autocor(/)
	*** *test_propCrit(/)
	*** *test_betterAffineZoom(/)
	*** *test_nonlinearity(/)
	*test_cor(/)
**


*** TODO:
*** ----------------------------------------------------
*** (*) порядок корреляционной иммунности (p.29 theorem 1.6)
*** (*) соверш. нелинейность (p.41)
*** (*) автокорреляция (p.51)
*** (*) степень распространения (p.56)
*** ----------------------------------------------------



*** ****************************************************************
*** *************************  Алгоритмы  **************************
*** ****************************************************************

*** Если L# булевый вектор, тогда в первом элементе находится количество переменных в нём, а размер булевого вектора = 1 < L#.0


test_autocor(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	1<L1.0+5⇒t *** 5 под запас, по сути не нужно, но на всякий случай
	@+L3(t)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFautocor(L1/L3)
	*sprint_complex(L3/) /'\n'>C
	
**

*** /' = '>C *printf(/) /'\n'>C
*** Автокорреляция
*** 
*** 
*** 
BFautocor(L1/L2)
	L1.0⇒m 1<m⇒n
	*** @+L3(n) n=Q3
	*BFpua(L1/L2)
	Oi Q2-1⇒t
	§1
		↑(i>t)2 L2i*L2i⇒L2i ∆i →1
	§2
		*BFpuaAlg(L2, 1/L2)
**


*** ****************************************************************
*** ********************  Propagation Criteria  **********************
*** ****************************************************************


test_propCrit(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFpropCrit(L1/m)
	/'m = '>C *printf(m/) /'\n'>C
**


*** ****************************************************************



*** Обёртка алгоритм критерий распространения(Propagation Criterion Algotithm)
*** 
*** 
BFpropCrit(L1/m)
	Om 1<L1.0⇒n
	*BFweight(L1/t)
	↑(t=n)1 ↑(t=0)1
	@+L2(n)
	*BFautocor(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFcorAlg(L2, m/m)
	§1
**


*** ****************************************************************


*** Алгоритм критерий распространения(Propagation Criterion Algotithm)
*** 
*** 
BFpropCritAlg(/)
	
	
	
**


*** ****************************************************************
*** ************************ Affine Zooming ************************
*** ****************************************************************


test_betterAffineZoom(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	*** OQ4 @'01110101101010101010101010101001'>F4
	OQ4 @'01111010'>F4
	*BFinput(F4/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFbetterAffineZoom(L1/L2)
	/'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	/'L2 = '>C *BFoutput_string(L2/) /'\n'>C
	
**



*** ****************************************************************



*** обёртка для алгоритма наилучшего аффинного приближения
BFbetterAffineZoom(L1/L2)
	1<L1.0⇒n
	@+L3(n)
	*BFpua(L1/L3)
	*BFpuaMaxSearch(L3/i, x)
	L1.0⇒L2.0 1⇒Q2
	*BFbetterAffineZoomAlg(L1, i/L2)
	/'n = '>C *printf(n/) /'\n'>C
**


*** ****************************************************************


*** Алгоритм наилучшего аффинного приближения
*** L1 - пустой булев вектор в который будет записан результат
*** l - индекс наибольшего значения из вектора после преобразования Уолша - Адамара
*** j - индекс текущего элемента
*** s - <= 32 возможных бита
BFbetterAffineZoomAlg(L1, l/L2)
	↑(Q1<1)6 ↑(L1.0<1)6
	Os⇒Z⇒i⇒c 1<L1i⇒m ∆i
	*** m:32+2=Q1-1=n ?(Z=0)1 Q1-1=Q1-1=n *** n для условия i не больше Q1-1
	*** m:32+2=Q1 количество элементов в символьном комплексе под
	*** значения функции с учётом того, что результат деления может быть
	*** с остатком. + 1 (нулевой элемент - количество переменных)
	§1
		Ox⇒j *** ?(i>n) может быть не нужно из-за (s>m)
	§2
		*** c - проверка, если в z уже записана одна переменная, значит
		*** следует делать сложение по модулю 2 иначе записать в z совпадение, c={0, 1}
		L1.0-k-1⇒t 1<t&l⇒y ↑(y=0)4 ↑(c=1)3 1<t&s>t⇒z ∆c →4
	§3
		1<t&s>t⊕z⇒z
	§4
		∆k ↑(k<L1.0)2
		z<j∨x⇒x ∆s ∆j Ok⇒c ↑(j>31)5 ↑(s<m)2
	§5
		x⇒L2i ∆i⇒Q2 ↑(s<m)1
	§6
**


*** ****************************************************************



*** значение по модулю (абсолютное значение)
absolut(x/y)
	x⇒y
	x&I31⇒t ↑(t=0)2
	§1
		x¬⇒y
	§2
**


*** ****************************************************************
*** ************************ NonLinearity  *************************
*** ****************************************************************


test_nonlinearity(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	OQ4 @'01110101101010101010101010101001'>F4
	*** OQ4 @'01111010'>F4
	*BFinput(F4/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFnonlinearity(L1/n)
	/'n = '>C *printf(n/) /'\n'>C
	
	
**


*** ****************************************************************



*** Вычисление значения нелинейности булевой функции
*** 
*** 
BFnonlinearity(L1/n)
	1<L1.0⇒n
	@+L2(n)
	*BFpua(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFpuaMaxSearch(L2/i, v)
	/'i = '>C *printf(i/) /'\n'>C
	/'v = '>C *printf(v/) /'\n'>C
	L1.0-1⇒n 1<n⇒n v/2⇒t n-t⇒n
**


*** ****************************************************************


*** Поиск наибольшего элемента в векторе после преобразования Уолша - Адамара
*** Используется для поиска наибольшего аффинного приближения и нелинейности
*** L1 - вектор после преобразования Уолша - Адамара
*** n - длина комплекса L1
*** i - индекс найденного элемента
*** v - (value) значение элемента
BFpuaMaxSearch(L1/j, v)
	Oi⇒j *absolut(L1i/v) ∆i Q1-1⇒m
	§1 
		↑(i>m)2
		*** /'L1i = '>C *printf(L1i/) /'\n'>C
		*absolut(L1i/u) ∆i ↑(u≤v)1 u⇒v i-1⇒j →1	*** если элемент больше
	*** предыдущего, запоминается его значение и индекс
	§2
**



*** ****************************************************************
*** ********************** Correlinearity  *************************
*** ****************************************************************


test_cor(/)
	@+L1(100)
	@+F2(100)
	*** OQ2 @'01110101101010101010101010101001'>F2
	OQ2 @'11000110'>F2
	*** OQ2 @'11111111'>F2
	*BFinput(F2/L1)
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C
	*BFcor(L1/m)
	/'m = '>C *printf(m/) /'\n'>C
	
	
**

*** ****************************************************************


*** Обёртка для алгоритма порядок корреляционной иммунности
*** 
*** 
BFcor(L1/m)
	L1.0⇒m 1<m⇒n
	*BFweight(L1/t)
	↑(t=n)1 ↑(t=0)1
	@+L2(n)
	*BFpua(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFcorAlg(L2, m/m)
	§1
**


*** ****************************************************************


*** Степень корреляционной иммунности. Алгоритм
*** Также используется при вычислении критерия распространения
*** 
BFcorAlg(L1, l/m)
	l-1⇒n 1⇒i
	§1 ↑(i>n)6
		1<i-1⇒d l-i⇒t d<t⇒b ↑(L1b≠0)7
	§2
		↑(b=d)5 b+1&b⇒c Ow c-1⊕b⇒q
	§3
		↑(q=0)4 q-1&q⇒q ∆w →3
	§4
		w-2⇒w b+1⊕b<1+1<w⊕c⇒b ↑(L1b≠0)7 →2
	§5
		∆i →1
	§6
		l⇒i
	§7
		i-1⇒m
**


*** ****************************************************************
*** ************************  Degree  ******************************
*** ****************************************************************


test_degree(/)
	@+L1(100)
	@+L2(100)
	@+L3(100)
	@+F4(100)
	*** OQ4 @'01110101101010101010101010101001'>F4
	OQ4 @'01110101101010101010101010101000'>F4
	*BFinput(F4/L1)
	*BFdegree(L1/d)
	/'d = '>C *printf(d/) /'\n'>C
	
**



*** ****************************************************************


*** как посчитать количество переменных(степень)?
*** степень булевой функции
*** L1 - булев вектор, после преобразования Мёбиуса
*** d - степень булева вектора
BFdegree(L1/d)
	Q2⇒n
	@+L2(n)
	*mobiusTransform(L1/L2)
	*BFoutput_string(L2/) /'\n'>C
	Od L2.0⇒n Q2-1⇒l
	31⇒i *** предполагается, что n > 5 (количество переменных больше 5), значит в булевой функции >= 32 значений
	*** но, если меньше, берётся значение 2^n
	↑(n>4)1 1<n-1⇒i
	*** /'i = '>C *printf(i/) /'\n'>C
	§1 ↑(L2l=0)2
		*** /'i = '>C *printf(i/) /'\n'>C *** /'n = '>C *printf(n/) /'\n'>C
		L2l&Ii⇒t ↑(t>0)3 →4 *** если t>0 значение степени найдено, переход в подсчёт переменных
	§2
		∇l 31⇒i ↑(l>0)1 →5 *** l должно быть больше 0, потому что первое значение комплекса это количество переменных в функции
	§3
		*** /'d = '>C *printf(d/) /'\n'>C
		l-1*32+i⇒t Oj t%⇒p t⇒q
		*** /'t = '>C *printf(t/) /'\n'>C
		*** /'p = '>C *printf(p/) /'\n'>C
		↑(p≤d)4 p⇒d
	§4
		↑(i=0)2 ∇i →1
	§5
		*** /'t = '>C *printf(t/) /'\n'>C
		*** /'j = '>C *printf(j/) /'\n'>C
		*** /'d = '>C *printf(d/) /'\n'>C
**


*** ****************************************************************
*** ***************************** PUA  *****************************
*** ****************************************************************


*** тестирование функции преобразования уолша-адамара
bool_pua_test(/)
	@+L1(10000000)
	
	28⇒n In+10⇒t
	@+L3(t)
	@+F2(100)
	*** 32=L1.0
	
	
	OQ2 @'0101'>F2
	*** OQ2 @'0011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'10010101'>F2
	*** OQ2 @'11111111'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'10100100'>F2
	*** OQ2 @'11000011'>F2
	*** OQ2 @'11000000'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'01100000'>F2
	*** OQ2 @'01110111'>F2
	*BFinput(F2/L1)
	
	
	/'t = '>C *printf(t/) /'\n'>C
	*** *BFrand(L1, n/L1) /'ok\n'>C
	
	
	*BFoutput_string(L1/) /'\n'>C
	*BFpua(L1/L3)
	*sprint_complex(L3/) /'\n'>C
	
	
**


*** ****************************************************************


*** превращение булева вектора в характеристический вектор
toCharactVect(L1/L2)
	Oi⇒j+1⇒l L1.0⇒n In⇒Q2
	§1
		Ij&L1l>j+2;3-1⇒L2i ∆i ∆j ↑(j>Q2)3 ↑(j>31)2 →1
	§2
		Oj ∆l ↑(l<Q1)1
	§3
**


*** ****************************************************************


*** Обёртка для алгоритма преобразование Уолша-Адамара
BFpua(L1/L2)
	*toCharactVect(L1/L2)
	*sprint_complex(L2/) /'\n'>C
	*BFpuaAlg(L2, 0/L2)
**


*** ****************************************************************


*** преобразование уолша-адамара
*** 
***  a   b   c   d
*** a+b a-b c+d c-d
***  e   f   g   h
*** e+g f+h e-g f-h
*** b - граница
*** e - сдвиг для алгоритма автокорреляции (не то e, что выше)
BFpuaAlg(L2, e/L2)
	Op⇒j⇒k 1⇒i⇒s Q2-1⇒n/2+1⇒m  *** 1<L1.0-1=n/2+1=m
	/'n = '>C *printf(n/) /'\n'>C
	§1
		 Ik⇒s Op⇒j ↑(s>m)5 ∆k
		§2
			L2j⇒a j+s⇒l L2l⇒b *** /'22\n'>C
			*** /'a = '>C *sprintf(a/) /'\n'>C
			*** /'b = '>C *sprintf(b/) /'\n'>C
			a+b⇒L2j a-b⇒L2l ↑(e=0)3
			*** возможно плохая идея приводить по модулю
			L2j;ffffffffh>e⇒L2j&I30<1⇒t L2j∨t⇒L2j
			L2l;ffffffffh>e⇒L2l&I30<1⇒t L2l∨t⇒L2l
			*** /'33\n'>C
			*** /'	j = '>C *printf(j/) /'\n'>C
			*** /'	l = '>C *printf(l/) /'\n'>C
			*** /'	p = '>C *printf(p/) /'\n'>C
			*** /'	s = '>C *printf(s/) /'\n'>C
			*** /'	m = '>C *printf(m/) /'\n'>C
		§3
			∆j ∆p ↑(l≥n)1 ↑(p≥s)4
			*** /'s = '>C *sprintf(s/) /'\n'>C
			*** /'j = '>C *sprintf(s/) /'\n'>C
			*** /'l = '>C *sprintf(s/) /'\n'>C
			→2
			*** ?=5
	§4
		j+s⇒j Op →2
	§5 *** /'qq\n'>C
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
**



*** /'a = '>C *printf(a/) /'\n'>C
*** /'b = '>C *printf(b/) /'\n'>C
*** /'c = '>C *printf(c/) /'\n'>C
*** /'d = '>C *printf(d/) /'\n'>C
*** ffffffffh=t /'t = '>C *sprintf(t/) /'\n'>C
*** 0-1⇒t /'t = '>C *printf(t/) /'\n'>C
*** /'L3l = '>C *sprintf(L3l/) /'\n'>C


*** ****************************************************************
*** *************************  Moebius  ****************************
*** ****************************************************************


*** тестирование функции преобразования Мёбиуса
bool_moebius_test(/)
	@+L1(100)
	@+L3(100)
	@+F2(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	*** OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	 OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*** *printf(Q2/) /'\n'>C
	*** /F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput_string(L1/) /'\n'>C /'\n'>C
	*** *moebiusTransform_mod(L1/L3)
	*mobiusTransform(L1/L3)
	
	*** *BFoutput(L1/) /'\n'>C
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L3/) /'\n'>C
	
	*** *moebiusTransform_mod(L3/L1)
	*mobiusTransform(L3/L3)
	*BFoutput_string(L3/) /'\n'>C /'\n'>C
	*** *BFoutput(L1/) /'\n'>C
	
	
**


*** ****************************************************************


*** Функция преобразование мобиуса для булева вектора
***
*** b - граница
***
mobiusTransform(L1/L2)
	@+L3(100)
	*** /'L1 = '>C *BFoutput_string(L1/) /'\n'>C
	Q1⇒Q2-1/2⇒n L1.0⇒L2.0 1⇒i⇒l Os *** <L1.0=k
	*** *printf(Q1/) /'\n'>C
	*** /'n = '>C *printf(n/) /'\n'>C
	§1
		L1i⇒g
		*** /'g = '>C *printf(g/) /'\n'>C
		g<1&aaaaaaaah⊕g⇒g
		g<2&cccccccch⊕g⇒g
		g<4&f0f0f0f0h⊕g⇒g
		g<8&ff00ff00h⊕g⇒g
		g<16&ffff0000h⊕g⇒L2i ∆i ↑(i<Q1)1
	§2
		1⇒i 1<s⇒l ↑(l>n)5 ∆s Ob
		§3
			i+l⇒j ∆b ↑(j>Q2)2 ↑(b>l)4 L2i⊕L2j⇒L2j ∆i →3
			*** /'i = '>C *printf(i/) /'\n'>C
		§4
			Ob i+l⇒i →3
	§5
**


*** ****************************************************************
*** ************************  ANF  *********************************
*** ****************************************************************


test_printANF(/)
	@+L1(100)
	@+F2(100)
	@+L3(100)
	*** 32=L1.0
	*** OQ2 @'01010011'>F2
	*** OQ2 @'01010101'>F2
	*** OQ2 @'01110101101010101010101010101001'>F2
	*** OQ2 @'11111111111111111111111111111111'>F2
	OQ2 @'01010101010101010101010101010101'>F2
	*** OQ2 @'0001000100011110'>F2
	*** OQ2 @'0001000100011110000100010001111000010001000111101110111011100001'>F2
	*** OQ2 @'00000000000000001111111111111111'>F2
	*** OQ2 @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101'>F2
	*** OQ2 @'01011111'>F2
	*** OQ2 @'11010110'>F2
	*** OQ2 @'11111111'>F2
	*** OQ2 @'0000000000000000000000000000000011111111111111111111111111111111'>F2
	*** OQ2 @'00000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111'>F2
	*** OQ2 @'0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'>F2
	*BFinput(F2/L1)
	*BFoutput_string(L1/) /'\n'>C
	1<L1.0⇒t
	@+F4(100)
	*printANF(L1/F4)
	/F4>C /'\n'>C
	
**


*** ****************************************************************



copySymbComplex(F1, F2/F2)
	Oi S2-1⇒n ↑(Q1<1)3
	§1
		F1i@>F2 ∆i ↑(Q2>n)2 ↑(i<Q1)1 →3
	§2
		/'copySymbComplex: Q2 больше чем его размерность\n'>C
	§3
**


*** ****************************************************************


*** Вывод АНФ
*** Возможно лучше сделать без преобразование Мёбиуса, учитывая, что вектор придёт уже после него
*** t - вначале для контроля шагов s, далее для получения значения из булевой функции, потом для получения значения переменной, затем для записи номера переменной
*** s - шаг значений в булевой функции
*** f - если 1, надо добавить знак +
*** j - счётчик переменных, показывает какая переменная была последней
*** i - 
*** k - значение переменных для которых функция равна 1
printANF(L1/F2)
	Q1⇒n OQ2
	@+L3(n)
	@+F4(10)
	*mobiusTransform(L1/L3)
	*BFoutput_string(L3/) /'\n'>C
	L3.0-1⇒n Q3-1⇒m 1⇒i Of
	§1
		Os
		↑(L3i=0)6 *** s=0 - начинаю с начала
	§2
		*** /'f = '>C *printf(f/) /'\n'>C
		↑(s>31)6 L3.0⇒t ↑(s>It)6 ↑(f=0)3 Of @' + '>F2
	§3
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'s = '>C *printf(s/) /'\n'>C
		L3i&Is⇒t
		*** /'t = '>C *printf(t/) /'\n'>C
		∆s ↑(t=0)2
		Oj i-1*32+s-1⇒k
		*** /'k = '>C *printf(k/) /'\n\n'>C
	§4
		1⇒f ↑(j>n)2
		*** /'s = '>C *printf(s/) /'\n'>C
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'k = '>C *printf(k/) /'\n'>C
		↑(k>0)5 @'1'>F2 →2
	§5 
		Ij&k⇒t ∆j
		*** /'t = '>C *printf(t/) /'\n'>C
		↑(t>0)7 →4
	§6
		∆i ↑(i<Q3)1 →8
	§7
		'X'@>F2 L3.0-j+1⇒t *** /'qq\n'>C
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'n = '>C *printf(n/) /'\n'>C
		*** /'j = '>C *printf(j/) /'\n'>C
		*** /'t = '>C *printf(t/) /'\n'>C
		OQ4 *n2s(t, 10/F4) *copySymbComplex(F4, F2/F2)
		*** /F2>C /'\n'>C
		→4 *** ?(j<=n)4 ?=4
	§8
		Q2-3⇒Q2
**

*** ****************************************************************
*** *******************  BF Generation *****************************
*** ****************************************************************


*** BFrand(L1/)
*** тестирование функции генератора булевой функции
bool_rand_test(/)
	@+L1(100)
	
	X X;10⇒t
	4⇒t
	*** /'main t = '>C *printf(t/) /'\n'>C
	*BFrand(L1, t/L1)
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	
**

*** ****************************************************************


*** генерация булевой функции от n переменных
*** n - количество переменных
*** s - шаг, идёт до размера булевой функции
*** L1 - булева функция
*** i - текущий элемент из L1
*** величина сдвига
BFrand(L1, n/L1)
	Oc⇒j 1⇒i n⇒L1.0
	1<n⇒t>5+2⇒Q1-1⇒l OL1l
	*** /'n = '>C *printf(n/) /'\n'>C
	*** /'t = '>C *printf(t/) /'\n'>C
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'L1.0 = '>C *printf(L1.0/) /'\n'>C
	16⇒s ↑(L1.0>3)2 t;32⇒s *** c;t?-3 вместо ?(c>=t)3 ?
	§2 X>s⇒L1i c+s⇒c ↑(c≥t)3 X>s<s∨L1i⇒L1i c+s⇒c ↑(c≥t)3 ∆i OL1i →2
	§3 *cutZerosBN(L1/L1) *** /'s = '>C *printf(s/) /'\n'>C
	*** *printf(L1.3/) /'\n'>C
	*** нужен ли cutZerosBN ?
**



*** ****************************************************************
*** *******************  Input/Output/Weight  **********************
*** ****************************************************************



*** сделать генератор
*** сделать алгоритм Мёбиуса
*** сделать цивилизованный вывод
*** нужно ли добавлять cutZerosBN ?
*** c;t-3 вместо ?(c>=t)3 ?


*** тестирование функций ввода/вывода, подсчёта размера булевой функции
bool_input_output_weight_test(/)
	@+L1(100)
	@+F2(100)
	*** 32=L1.0
	OQ2
	@'0111010110101010101010101010100101010101010101010101010101101101110111001001001101110101101010101010101010101001010101010101010101110101101010101010101010101001010101010101010101010101011011011101110010010011011101011010101010101010101010010101010101010101'>F2
	*** @'0111010110101010101010101010100101010101010101010101010101101101'>F2
	/F2>C /'\n'>C
	*** *printf(Q2/) /'\n'>C
	*BFinput(F2/L1)
	*** *printf(L1.0/) /'\n'>C
	/'Q1 = '>C *printf(Q1/) /'\n'>C
	*BFoutput(L1/) /'\n'>C
	*BFweight(L1/n)
	*printf(n/) /'\n'>C
	
**


*** ****************************************************************


*** 
*** L1.0 - размер булевой функции
*** ввод булевой функции
BFinput(F1/L2)
	OQ2 ↑(Q1<1)6
	Q1⇒s-1&s↦6 *** проверка длины входных значений
	Oj⇒i⇒z
	*** задаётся размер комплекса
	*** число функций делится на 32 и добавляется ещё 2 элемента 1 под количество переменных один резервный, который в конце отбрасывается, если не понадобится
	Q1⇒n>5+2⇒Q2-1⇒t OL2t
	§1 ∆i⇒L2.0 n>1⇒n↦1 ∇L2.0 Oi *** подсчёт переменных в функции
	*** /'Q2 = '>C *printf(Q2/)  /'\n'>C *** размер функции
	*** /'L2.0 = '>C *printf(L2.0/)  /'\n'>C *** количество переменных
	∆j OL2j
	§2 F1i-48↦3 L2j →4
	§3 1<z⇒t L2j∨t⇒L2j
	§4 ∆z ∆i ↑(i=Q1)7 i;32↪5 →2
	§5 ∆j Oz OL2j →2
	§6 /'Ошибка: Возможно пустой символьный комплекс или длина булевой функции\n'>C
	§7 Q2-1⇒l ↑(L2l>0)8 l⇒Q2 *** *cutZerosBN(L2/L2)
		 *** *printf(L2.0/) /' '>C *printf(L2.1/) /' '>C *printf(L2.2/) /' '>C *printf(Q2/)  /'\n'>C
	§8
**

*** ****************************************************************


*** 
*** n - размер булевой функции
*** вывод булевой функции со значениями переменных
BFoutput(L1/)
	↑(Q1<1)3
	Oi
	§1 ↑(i≥L1.0)2 /' X'>C *printf(i/) /' '>C ∆i →1
	§2 /'| f \n'>C Oi
	§3 ↑(i≥L1.0)4 /'----'>C ∆i →3
	§4 /'----\n'>C
	Oz⇒c 1⇒i 1<L1.0⇒n
	§5 0⇒j 1<L1.0>1⇒l 1<z⇒q L1i&q>z⇒t ∆c
		 *** *printf(c/) /' '>C
		 §8
			↑(j≥L1.0)9 L1.0-j-1⇒w c-1&l>w⇒w /' '>C *printf(w/) /'  '>C l>1⇒l ∆j →8
		 §9
			/'| '>C *printf(t/) /' '>C
		 ∆z ↑(z=32)6 ↑(c=n)7 /'\n'>C →5
	§6 Oz ∆i ↑(i=Q1)7 /'\n'>C →5
	§7 *** /'\n'>C
**

*** ****************************************************************


*** 
*** n - размер булевой функции
*** вывод булевой функции строкой или в столбик
BFoutput_string(L1/)
	↑(Q1<1)3
	Oz⇒c 1⇒i 1<L1.0⇒n
	§1 1<z⇒t L1i&t>z⇒t ∆c
		 *** *printf(c/) /' '>C
		 *printf(t/) *** /'\n'>C
		 ∆z ↑(z=32)2 ↑(c=n)3 →1
	§2 Oz ∆i ↑(i=Q1)3 →1
	§3 *** /'\n'>C
**


*** ****************************************************************


BFweight(L1/n)
	↑(Q1<1)2 Oi⇒n ∆i
	§1 L1i%+n⇒n ∆i ↑(i<Q1)1
	§2
**




*** ****************************************************************
*** ************************  BACKUP  ******************************
*** ****************************************************************



*** /' = '>C *printf(/) /'\n'>C
*** Автокорреляция
*** 
*** 
*** 
BFautocor_bak(L1/L2)
	L1.0⇒m 1<m⇒n
	@+L3(n) n⇒Q3
	*toCharactVect(L1/L2)
	/'L2 = '>C *sprint_complex(L2/) /'\n'>C
	Oi⇒f+1⇒j /'		*************** Cycle1 ******************\n'>C
	§93									*** Начало cycle1
		Ok /'		*************** Cycle2 ******************\n'>C
	§94									*** Начало cycle2
		Ol⇒q j-1⇒o /'		*************** Cycle3 ******************\n'>C
	§95									*** Начало cycle3,4
		↑(l>o)97
		k+l⇒p+q⇒t p+j⇒e
		*** /'q = '>C *sprintf(q/) /'\n'>C
		*** /'p = '>C *sprintf(p/) /'\n'>C
		*** /'e = '>C *sprintf(e/) /'\n'>C
		*** /'t = '>C *sprintf(t/) /'\n'>C
		*** /'L2p = '>C *sprintf(L2p/) /'\n'>C
		*** /'L2e = '>C *sprintf(L2e/) /'\n'>C
		*** /'L3t = '>C *sprintf(L3t/) /'\n'>C
		↑(q>0)96 L2p+L2e⇒L3t ∆l →95
	§96
		L2p-L2e⇒L3t ∆l →95
	§97									*** триггер для 4го цикла основан на значении q
											*** если q>0, значит цикл уже проходил, переход к следующему шагу
		*** /'L3 = '>C *sprint_complex(L3/) /'\n'>C
		*** /'L2 = '>C *sprint_complex(L2/) /'\n'>C
		↑(q>0)98 Ol j⇒q
		/'		*************** Cycle4 ******************\n'>C
		→95
	§98
		j<1-1⇒o Ol /'		*************** Cycle5 ******************\n'>C
		/'L3 = '>C *sprint_complex(L3/) /'\n'>C
		/'L2 = '>C *sprint_complex(L2/) /'\n'>C
	§99									*** Начало cycle5
		↑(l>o)100 l+k⇒t
		/'f = '>C *sprintf(f/) /'\n'>C
		/'t = '>C *sprintf(t/) /'\n'>C
		/'		Before\n'>C
		/'L2t = '>C *sprintf(L2t/) /'\n'>C
		/'L3t = '>C *sprintf(L3t/) /'\n'>C
		/'L3t = '>C *printf(L3t/) /'\n'>C
		L3t&I31⇒v L3t;ffffffffh>f⇒L2t&I30⇒v
		/'		After\n'>C
		/'L2t = '>C *sprintf(L2t/) /'\n'>C
		/'L3t = '>C *sprintf(L3t/) /'\n'>C
		/'L3t = '>C *printf(L3t/) /'\n'>C
		∆l →99
	§100
		/'f = '>C *sprintf(f/) /'\n'>C
		/'L3 = '>C *sprint_complex(L3/) /'\n'>C
		/'L2 = '>C *sprint_complex(L2/) /'\n'>C
		j<1+k⇒k ↑(k<m)94 ∆i j<1⇒j ↑(i<m)93
											*** триггер для перехода между
											*** двумя частями, основан на значении f
											*** если f>0, значит выход
		↑(f>0)103 Oi Q2-1⇒t
	§101
		↑(i>t)102 L2i*L2i⇒L2i ∆i →101
	§102
		Oi+1⇒f⇒j
		/'		*************** Cycle1 ******************\n'>C
		→93
	§103
**





printANF_bak(L1/F2)
	Q1⇒n OQ2
	@+L3(n)
	@+F4(10)
	*mobiusTransform(L1/L3)
	*BFoutput_string(L3/) /'\n'>C
	L3.0-1⇒n Q3-1⇒m 1⇒i Of
	§91
		Os
		↑(L3i=0)93 *** s=0 - начинаю с начала
	§92
		/'f = '>C *printf(f/) /'\n'>C
		↑(s>31)93 L3.0⇒t ↑(s>It)93 ↑(f=0)96 Of @' + '>F2
	§96
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'s = '>C *printf(s/) /'\n'>C
		L3i&Is⇒t
		*** /'t = '>C *printf(t/) /'\n'>C
		∆s ↑(t=0)92
		Oj i-1*32+s-1⇒k
		*** /'k = '>C *printf(k/) /'\n\n'>C
	§94
		1⇒f ↑(j>n)92
		*** /'s = '>C *printf(s/) /'\n'>C
		*** /'i = '>C *printf(i/) /'\n'>C
		*** /'k = '>C *printf(k/) /'\n'>C
		↑(k>0)97 @'1'>F2 →92
	§97 
		Ij&k⇒t ∆j
		*** /'t = '>C *printf(t/) /'\n'>C
		↑(t>0)95 →94
	§93
		∆i ↑(i<Q3)91 →100
	§95
		'X'@>F2 L3.0-j+1⇒t *** /'qq\n'>C
		/'i = '>C *printf(i/) /'\n'>C
		/'n = '>C *printf(n/) /'\n'>C
		/'j = '>C *printf(j/) /'\n'>C
		/'t = '>C *printf(t/) /'\n'>C
		OQ4 *n2s(t, 10/F4) *copySymbComplex(F4, F2/F2)
		*** /F2>C /'\n'>C
		→94 *** ?(j<=n)94 ?=94
	§100
		Q2-3⇒Q2
**




BFpuaAlg_bak(L2, e/L2)
	Op⇒j⇒k 1⇒i⇒s Q2-1⇒n/2+1⇒m  *** 1<L1.0-1=n/2+1=m
	/'n = '>C *printf(n/) /'\n'>C
	§97
		 Ik⇒s Op⇒j ↑(s>m)100 ∆k
		§98
			L2j⇒a j+s⇒l L2l⇒b *** /'22\n'>C
			/'a = '>C *sprintf(a/) /'\n'>C
			/'b = '>C *sprintf(b/) /'\n'>C
			a+b⇒L2j a-b⇒L2l ↑(e=0)96
			*** возможно плохая идея приводить по модулю
			L2j;ffffffffh>e⇒L2j&I30<1⇒t L2j∨t⇒L2j
			L2l;ffffffffh>e⇒L2l&I30<1⇒t L2l∨t⇒L2l
			*** /'33\n'>C
			*** /'	j = '>C *printf(j/) /'\n'>C
			*** /'	l = '>C *printf(l/) /'\n'>C
			*** /'	p = '>C *printf(p/) /'\n'>C
			*** /'	s = '>C *printf(s/) /'\n'>C
			*** /'	m = '>C *printf(m/) /'\n'>C
		§96
			∆j ∆p ↑(l≥n)97 ↑(p≥s)99
			*** /'s = '>C *sprintf(s/) /'\n'>C
			*** /'j = '>C *sprintf(s/) /'\n'>C
			*** /'l = '>C *sprintf(s/) /'\n'>C
			→98
			*** ?=100
	§99
		j+s⇒j Op →98
	§100 *** /'qq\n'>C
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
**


*************************************************
******* 	Надо сделать красивее_end	 ********
*************************************************


********************************************************************************
************	Алгоритмы над булевыми функциями закончились	************
********************************************************************************


********************************************************************************
*************************	Алгоритмы RSA начались	**************************
********************************************************************************


main_rsa(/)
	@+L1(1000) OQ1
	@+L2(1000) OQ2
	@+L3(1000) OQ3
	@+L4(1000) OQ4
	@+F5(100)
	/F5<C
	*s2n(F5, 10/n)
	*** *EuclAlg_test(/)
	*** *dih_bar_test(/)
	*** *degree_tset(/)
	*** *extEuclAlg_test2(/)
	*** *extEuclAlg_rowTest(/)
	*** *rsaGen_test(/)
	*** 1024=n
	*** P1
	*printf(n/) /'\n'>C
	*rsaEncrypt_test(n/L1, L2, L3, L4)
	
	T⇒t
	*rsaDecrypt_test(L4, L3, L1, L2/)
	T-t⇒t
	/'n = '>C *printf(n/) /'\n'>C
	/'Время?\n'>C *printf(t/) /'\n'>C
	/'\n**************************************************\n'>C
	*** ?(n<10)2
	*** n-10=n
	*** ?=1
	*** *ttt(/)
	§2
**


*** echo -n > rsa_encr.txt > rsa_decr.txt && ./rsa_ | tee output.txt

*** возможна проблема, если числа будут отрицательными в rsaGen
*** в powBN_bar L1;L3⇒L5 не заменяется на barmod(...)


***********************************************************
*********************    Алгоритмы    *********************
***********************************************************


emptyShot(n/)
	Oi
	§1
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		X X X X X X X X X X X X
		∆i ↑(i<n)1
	§2
**




*** поиск обратного числа, основан на алгоритме Евклида,
*** только возвращает меньше значений и присваивает
*** переменной обратного элемента ноль, если числа не
*** взаимнопросты
*** L1 - число a для которого ищется обратный элемент
*** L2 - модуль m
*** L3 = y: a*y = 1 mod m (L1*L3 = 1 mod L2)
*** L4 - c - Наибольший общий делитель L1, L2
BNinvElement(L1, L2/L3, L4)
	@+L6(1000) OQ6 *** c
	@+L7(1000) OQ7 *** d
	@+L8(1000) OQ8 *** y
	@+L9(1000) OQ9 *** w
	@+L10(1000) OQ10 *** q
	@+L11(1000) OQ11 *** r
	@+L12(1000) OQ12 *** t
	Of⇒L8.0+1⇒L9.0⇒Q8⇒Q9⇒Q12 0⇒L12.0 L1⇒L6 L2⇒L7 *BN_neq(L1, L12/a) ↑(a=1)1 ∆L8.0 L2⇒L5 →4
	§1
		∆f;2⇒f 1⇒Q12 OL12.0 *BN_eq(L7, L12/a) ↑(a=1)2
		L6/L7⇒L10 Q10+Q7⇒l
		*karatsuba(L10, L7/L11)
		L6-L11⇒L11 *cutZerosBN(L11/L11)
		*karatsuba(L10, L9/L12)
		Q8+1⇒l ↑(Q8>Q12)5 Q12+1⇒l
	§5
		*optimize(L8, l/L8)
		L8+L12⇒L8 *cutZerosBN(L8/L8)
		L7⇒L6 L11⇒L7 L9⇒L12 L8⇒L9 L12⇒L8 →1
	§2
		1⇒Q3⇒Q10⇒L10.0-1⇒L3.0 *BN_gr(L6, L10/a) ↑(a>0)4
		*karatsuba(L2, L8/L12)
		↑(f>0)3
		L12-L6/L1⇒L3 L2-L3⇒L3
		*cutZerosBN(L3/L3) →4
	§3
		Q12⇒i Q12+1⇒Q12 OL12i L12+L6/L1⇒L3 *** проверить мощность L3 и L12 до и после увеличения на 1
	§4
		L6⇒L4
**



ttt(/)
	@+L1(1000)
	@+L2(1000)
	@+F3(1000)
	
	OQ3 @'0x2'>F3 *inputBN_2(L1, F3/L1)
	OQ3 @'0x3777BF4446C2C4159FF940DAF0135123FE4641C05A0171C1A31E6776E848A96F21A72B7C7DC75FAD6F253B52096FBFFBBDAAD8780B7199D9F413386F'>F3 *inputBN_2(L2, F3/L2)
	
	*HprintfBN(L1/) /'\n'>C
	*HprintfBN(L2/) /'\n'>C
	
	
	/'1\nQ1 = '>C *printf(Q1/) /'\n'>C
	/'Q2 = '>C *printf(Q2/) /'\n'>C
	L1;L2⇒L2
	
	/'2\nQ1 = '>C *printf(Q1/) /'\n'>C
	/'Q2 = '>C *printf(Q2/) /'\n'>C
	*HprintfBN(L2/) /'\n'>C
	
**


*** Расширенный алгоритм Евклида
*** https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%§1%80%D0%B8%§1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0#.D0.A0.D0.B0.§1.81.§1.88.D0.B8.§1.80.D0.B5.D0.BD.D0.BD.§1.8B.D0.B9_.D0.B0.D0.BB.D0.B3.D0.BE.§1.80.D0.B8.§1.82.D0.BC_.D0.95.D0.B2.D0.BA.D0.BB.D0.B8.D0.B4.D0.B0_.D0.B8_.§1.81.D0.BE.D0.BE.§1.82.D0.BD.D0.BE.§1.88.D0.B5.D0.BD.D0.B8.D0.B5_.D0.91.D0.B5.D0.B7.§1.83
*** L3 - x - коэффициент при L1
*** L4 - y - коэффициент при L2
*** L5 - наибольший общий делитель L1 и L2
*** f - признак отрицательного числа L3 или L4
BNextEuclAlg(L1, L2/L3, L4, L5, f)
	@+L6(1000) OQ6 *** c
	@+L7(1000) OQ7 *** d
	@+L8(1000) OQ8 *** y
	@+L9(1000) OQ9 *** w
	@+L10(1000) OQ10 *** q
	@+L11(1000) OQ11 *** r
	@+L12(1000) OQ12 *** t
	
	Of⇒L8.0+1⇒L9.0⇒Q8⇒Q9⇒Q12 0⇒L12.0 L1⇒L6 L2⇒L7 *BN_neq(L1, L12/a) ↑(a=1)1 ∆L8.0 L2⇒L5 →4
	§1
		∆f;2⇒f 1⇒Q12 OL12.0 *BN_eq(L7, L12/a) ↑(a=1)2
		L6/L7⇒L10 Q10+Q7⇒l
		*karatsuba(L10, L7/L11)
		L6-L11⇒L11 *cutZerosBN(L11/L11)
		*karatsuba(L10, L9/L12)
		Q8+1⇒l ↑(Q8>Q12)5 Q12+1⇒l
		
	§5
		*optimize(L8, l/L8)
		L8+L12⇒L8 *cutZerosBN(L8/L8)
		L7⇒L6 L11⇒L7 L9⇒L12 L8⇒L9 L12⇒L8 →1
	§2
		
		*karatsuba(L2, L8/L12)
		↑(f>0)3
		L12-L6/L1⇒L3 →4
	§3
		Q12⇒i Q12+1⇒Q12 OL12i L12+L6/L1⇒L3 *** проверить мощность L3 и L12 до и после увеличения на 1
	§4
		*cutZerosBN(L3/L3)
		L8⇒L4
		L6⇒L5
**

*** Q2+Q8=l *optimize(L12, l/L12) 1=L12.0 L12*L2*L8=L12



*** L2 - закрытый ключ, d
*** L3 - закрытый ключ, n
*** L4 - открытый ключ, p
*** L5 - закрытый ключ, q
rsaDecrypt_test(L2, L3, L4, L5/)
	@+F1(1000) OQ1
	255⇒n
	*** /'p = '>C *HprintfBN(L4/) /'\n'>C
	*** /'q = '>C *HprintfBN(L5/) /'\n'>C
	*** /'n = '>C *HprintfBN(L3/) /'\n'>C
	*** /'d = '>C *HprintfBN(L2/) /'\n'>C
	/'		RSA Decrypt Algorithm\n		You`re Welcome!\n'>C
	
	OQ1 @'rsa_encr.txt'>F1
	*fopen(F1, 0/a)
	OQ1 @'rsa_decr.txt'>F1
	*fopen(F1, 1/b)
	*** /'descriptor a = '>C *printf(a/) /'\n'>C
	*** /'descriptor b = '>C *printf(b/) /'\n'>C
	
	*** *countBits(L3/n)
	Q3*4⇒n
	§1
	*** /'bytsDec = '>C *printf(n/) /'\n'>C
	*BNrsaDecrypt(n, a, b, L2, L3, L4, L5/e)
	*fclose(a/)
	*fclose(b/)
	*** /'L2 = '>C *HprintfBN(L2/) /'\n'>C
**



*** 
*** 
*** 
*** 
rsaGarnersAlgorithm()
	
	
	
	
	
**


*** 
*** 
*** 
rsaChinRemAlg(L1, L2, L3, L4/L5)
	@+L6(1000) *** M
	@+L7(1000) *** M^(-1)p
	@+L8(1000) *** M^(-1)q
	*** /'\n\nrsaChinRemAlg:\n'>C
	
	
	*BNinvElement(L4, L3/L7, L6)
	*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n\n'>C
	*BNinvElement(L3, L4/L8, L6)
	*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
	*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
	*karatsuba(L3, L4/L6) *** L6 = M
	*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
	*karatsuba(L7, L4/L7)
	*** /'L7 = '>C *HprintfBN(L7/) /'\n\n'>C
	*karatsuba(L7, L1/L7)
	*** /'L7 = '>C *HprintfBN(L7/) /'\n\n'>C
	*karatsuba(L8, L3/L8)
	*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
	*karatsuba(L8, L2/L8)
	*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
	*** /'Q7 = '>C *printf(Q7/) /'\n'>C
	*** /'Q8 = '>C *printf(Q8/) /'\n'>C
	*** /'L7 = '>C *HprintfBN(L7/) /'\n\n'>C
	*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
	*** ?(Q7>Q8)2
	*** P1
	Q7+Q8⇒l *optimize(L8, l/L8)
	L8+L7;L6⇒L8 *** ?=3
	*** P2
		*** L7+L8;L6=L8
	*** P3
		Q6⇒Q8
	*** /'L8 = '>C *HprintfBN(L8/) /'\n'>C
	L8⇒L5
**



*** расшифрование блока зашифрованного сообщения
*** методом китайской теоремы об остатках
*** L1 - число p из разложения числа N = p*q
*** L2 - число q из разложения числа N ⇒ p*q
*** L3 - число d секретная экспонента
*** L4 - число C - зашифрованное значение
crt_decrypt(L1, L2, L3, L4/L10)
	@+L5(1000) OQ5 *** d mod (p-1), C^(d mod(p-1)), mp
	@+L6(1000) OQ6 *** d mod (q-1), C^(d mod(q-1)), mq
	@+L7(1000) OQ7 *** вспомогательное слагаемое для алгоритма баррета z
	@+L8(1000) OQ8 *** 1
	*** /'\n\ncrt_decrypt:\n'>C
	*** /'p = '>C *HprintfBN(L1/) /'\n'>C
	*** /'q = '>C *HprintfBN(L2/) /'\n'>C
	*** /'d = '>C *HprintfBN(L3/) /'\n'>C
	*** /'C = '>C *HprintfBN(L4/) /'\n'>C
	
	1⇒Q8⇒L8.0
	L1-L8⇒L5 *** L5 = p-1
	L2-L8⇒L6 *** L6 = q-1
	*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	*** /'Q2 = '>C *printf(Q2/) /'\n'>C
	*** /'Q5 = '>C *printf(Q5/) /'\n'>C
	*** /'Q6 = '>C *printf(Q6/) /'\n'>C
	
	*** /'p-1 = '>C *HprintfBN(L5/) /'\n'>C
	*** /'q-1 = '>C *HprintfBN(L6/) /'\n'>C
	
	
	Q5*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L5⇒L7
	*** *barmod(L3, L5, L7/L5) *** L5 = d mod (p-1)
	Q5⇒t L3;L5⇒L5 t⇒Q5 *** L5 = d mod (p-1)
	
	Q6*2⇒Q7 OL7
	Q7⇒k+1⇒Q7 1⇒L7k L7/L6⇒L7
	*** *barmod(L3, L6, L7/L6) *** L6 = d mod (q-1)
	Q6⇒t L3;L6⇒L6 t⇒Q6 *** L6 = d mod (q-1)
	
	*** /'dp = '>C *HprintfBN(L5/) /'\n\n'>C
	*** /'dq = '>C *HprintfBN(L6/) /'\n\n'>C
	
	*powBN_karat(L4, L5, L1/L5) *** L5 = C^(d mod(p-1)) mod p
	*powBN_karat(L4, L6, L2/L6) *** L6 = C^(d mod(q-1)) mod q
	
	*** /'Cp = '>C *HprintfBN(L5/) /'\n\n'>C
	*** /'Cq = '>C *HprintfBN(L6/) /'\n\n'>C
	
	*rsaChinRemAlg(L5, L6, L1, L2/L6)
	*** /'result = '>C *HprintfBN(L6/) /'\n'>C
	
	L6⇒L10
	
**



*** преобразование блока чисел в логическом комплексе
*** в символы в символьном комплексе без учёта нулевых
*** символов
*** требуется для алгоритма rsa в расшифровании
*** e - признак ошибки
blockToStr_forDecrypt(L1, F2/F2, e)
	Oe⇒j Q1*4-1⇒Q2
	Q1-1⇒i 24⇒s
	§1
		L1i>s⇒F2j ↑(F2j=0)2 ∆j
	§2
		s-8⇒s ↑(s>24)3 →1
	§3
		∇i 24⇒s ↑(i<Q1)1
		*** /'j = '>C *printf(j/) /'\n'>C
		j⇒Q2
**


*** Алгоритм расшифрования сообщения зашифрованного методом RSA
*** n - число байт для считывания
*** r - дескриптор файла для считывания
*** w - дескриптор файла для записи
*** L1 - число d, закрытая экспонента
*** L2 - число n, модуль
*** L3 - число p, закрытая ключ
*** L4 - число q, закрытая ключ
*** e - признак ошибки
BNrsaDecrypt(n, r, w, L1, L2, L3, L4/e)
	@+F5(1000) OQ5
	@+L6(1000) OQ6
	Ok *** /'n Dec = '>C *printf(n/) /'\n'>C
	T⇒p 
	§1
		Ok
		*freadf(r, F5, 0, n/k)
		*** /'k = '>C *printf(k/) /'\n'>C
		↑(k=0)2 k⇒Q5 *** /F5>C
		*** /'\n\nk = '>C *printf(k/) /'\n'>C
		*strToBlock(F5, L6/L6, e)
		*** /'\n\nQ5 = '>C *printf(Q5/) /'\n'>C
		Q6⇒t
		*** /'L6 encrypted:\n'>C
		*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
		*crt_decrypt(L3, L4, L1, L6/L6)
		*** *powBN_karat(L6, L1, L2/L6)
		*** /'L6 decrypted:\n'>C
		*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
		*** /'Q6 = '>C *printf(Q6/) /'\n'>C
		t⇒Q6
		OQ5 *blockToStr_forDecrypt(L6, F5/F5, e)
		*fwritef(w, F5, 0, Q5/k)
		*** /F5>C
		→1
	§2
		T-p⇒p
		/'\np = '>C *printf(p/) /'\n'>C
**



countBits(L1/n)
	↑(Q1=0)2 Q1-1⇒i*32⇒n
	32⇒s
	§1
		∇s ↑(s>31)2 1<s&L1i↪1 s+1+n⇒n
	§2
**



*** k - количество бит
*** L2 - закрытый ключ, p
*** L3 - закрытый ключ, q
*** L4 - открытый ключ, n
*** L5 - открытый ключ, e
*** L6 - закрытый ключ, d
rsaEncrypt_test(k/L2, L3, L4, L6)
	@+F1(100) OQ1
	@+L5(1000) OQ5
	*BNrsaGen(k/L2, L3, L4, L5, L6)
	*** /'p = '>C *HprintfBN(L2/) /'\n'>C
	*** /'q = '>C *HprintfBN(L3/) /'\n'>C
	*** /'n = '>C *HprintfBN(L4/) /'\n'>C
	*** /'e = '>C *HprintfBN(L5/) /'\n'>C
	*** /'d = '>C *HprintfBN(L6/) /'\n'>C
	OQ1 @'text.txt'>F1
	*fopen(F1, 0/a)
	OQ1 @'rsa_encr.txt'>F1 *** /F1>C /'\n'>C
	*fopen(F1, 1/b)
	↑(a=0)3 ↑(b=0)3
	*** /'descriptor a = '>C *printf(a/) /'\n'>C
	*countBits(L4/n)
	↑(n>8)1 2⇒n →2
	§1
		OZ n:8⇒n ↑(Z=0)2 ∆n
	§2
		∇n
		*** /'bytesEncr = '>C *printf(n/) /'\n'>C
		*BNrsaEncrypt(n, a, b, L5, L4/e)
	*fclose(a/)
	*fclose(b/) →4
	§3 /'ОШИБКА: Один из дескрипторов не работает\n'>C
	§4
**


*** https://ru.wikipedia.org/wiki/RSA#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80
*** генерация ключей для алгоритма RSA
*** L1 - закрытый ключ, p
*** L2 - закрытый ключ, q
*** L3 - открытый ключ, n
*** L4 - открытый ключ, e
*** L5 - закрытый ключ, d
BNrsaGen(k/L1, L2, L3, L4, L5)
	@+L6(1000) OQ6
	@+L7(1000) OQ7
	OQ1⇒Q2⇒Q3⇒Q4⇒Q5
	↑(k<3)4
	@+L8(4) OQ8
	*** открытая экспонента может быть равна {3, 17, 257, 65537}
	4⇒Q8 3⇒L8.0+14⇒L8.1+240⇒L8.2+65280⇒L8.3
	*** возможна проблема, если числа будут отрицательными
	OZ⇒s k:32⇒q Z↪1 1⇒s
	*** /'q = '>C *printf(q/) /'\n'>C
	*** /'s = '>C *printf(s/) /'\n'>C
	§1
		q+s⇒Q1⇒Q2
		k/10⇒r 102-r*2+1⇒r
		*emptyShot(r/)
		*** T=X
		/'k = '>C *printf(k/) /'\n'>C
		/'p generates... '>C
		*randPrimeBN(k/L1)
		*emptyShot(1/)
		*** T=X
		/'\nq generates... '>C
		*randPrimeBN(k/L2)
		/'\nDone\n'>C
		*** /'L1 = '>C *HprintfBN(L1/) /'\n'>C
		*** /'Q1 = '>C *printf(Q1/) /'\n'>C
	1⇒Q3⇒L3.0
	L1-L3⇒L4 *** p-1
	L2-L3⇒L3 *** q-1
	*** L5 = Ф(n) = (p-1)*(q-1)
	*karatsuba(L3, L4/L5)
	*** L3 = n = p*q
	*karatsuba(L1, L2/L3)
	Oj+1⇒Q4
	§2
		L8j⇒L4.0
		*BNinvElement(L4, L5/L6, L7)
		*** /'L4 = '>C *HprintfBN(L4/) /'\n\n'>C
		*** /'L5 = '>C *HprintfBN(L5/) /'\n\n'>C
		*** /'L6 = '>C *HprintfBN(L6/) /'\n\n'>C
		*** /'L7 = '>C *HprintfBN(L7/) /'\n\n'>C
		*** L4 приравниваю к 1 для сравнения с наибольшим
		*** общим делителем, чтобы не заводить новый комплекс
		*** значение, при котором был найден обратный элемент
		*** с наибольшим общим делителем равным 1 лежит в L8
		*** j-1 элементе
		∆j 1⇒L4.0 *BN_eq(L7, L4/a) ↑(j>3)3 ↑(a≠1)2
	∇j L8j⇒L4.0
	L6⇒L5
	*** /'L5 = '>C *HprintfBN(L5/) /'\n'>C
	→4
	§3 /'Ошибка: Что то не так с j в P2\n'>C *** на всякий случай, по теории, ошибки не должно быть
	§4
**




*** преобразование блока символов в логический комплекс
*** каждый символ это два числа в шестнадцатеричной
*** системе счисления.
*** требуется для алгоритма rsa
*** e - признак ошибки
strToBlock(F1, L2/L2, e)
	OZ⇒e Q1:4⇒n ↑(Z=0)1 ∆n
	§1
		n⇒Q2
	Oj⇒s Q1-1⇒i OL2j
	§2
		*** *printf(F1i/) /'\n'>C
		F1i<s∨L2j⇒L2j
		∇i s+8⇒s ↑(i≥Q1)4 ↑(s>24)3 →2
	§3
		∆j OL2j⇒s →2
	§4
		s-8⇒s ffffffffh>s&L2j
**


*** преобразование блока чисел в логическом комплексе
*** в символы в символьном комплексе
*** требуется для алгоритма rsa
*** e - признак ошибки
blockToStr(L1, F2/F2, e)
	Oe⇒j Q1-1⇒i+1*4⇒Q2
	24⇒s
	§1
		L1i>s⇒F2j
		*** *printf(F2j/) /'\n'>C
		∆j s-8⇒s ↑(s>24)2 →1
	§2
		∇i 24⇒s ↑(i<Q1)1
	§3
**


*** Алгоритм шифрования сообщения методом RSA
*** n - число байт для считывания из файла. В общей
*** сложности количество бит в этих байтах должно быть
*** меньше бит в n(модуле, тот, что L4)
*** r - дескриптор файла, с которого производить чтение
*** сообщения
*** w - дескриптор файла, в который производить запись
*** зашифрованного сообщения
*** L3 - e - открытая экспонента
*** L4 - n - модуль
*** e - признак ошибки(не то e, что выше)
BNrsaEncrypt(n, r, w, L3, L4/e)
	@+F1(1000) OQ1
	Q4*4⇒t
	@+F2(t) OQ2
	@+L5(1000) OQ5
	@+L8(1000) OQ8
	@+L11(1000) OQ11
	Oe *** /'n = '>C *printf(n/) /'\n'>C
	§1
		
		OQ1 *freadf(r, F1, 0, n/k)
		*** /'k = '>C *printf(k/) /'\n'>C
		*** обработать случай, когда k может означать ошибку
		k⇒Q1 Oi ↑(k=0)2
		*** *printFComplex(F1/)
		*strToBlock(F1, L5/L5, e)
		*** /F1>C
		*** /'\n\n ##################################\n\n'>C
		*** /'\nQ4 = '>C *printf(Q4/) /'\n'>C
		Q4-1⇒t OL8t
		*powBN_karat(L5, L3, L4/L8)
		*** /'L4 = '>C *HprintfBN(L4/) /'\n'>C /'\n'>C
		*** /'L8 = '>C *HprintfBN(L8/) /'\n\n'>C
		*** /'L5 = '>C *HprintfBN(L5/) /'\n\n'>C
		*** /'Q8 = '>C *printf(Q8/) /'\n'>C
		Q4⇒Q8
		OQ2 *blockToStr(L8, F2/F2, e)
		*** /'Q2 = '>C *printf(Q2/) /'\n'>C
		*fwritef(w, F2, 0, Q2/k)
		*** /'k = '>C *printf(k/) /'\n'>C
		*** если k меньше Q2 e = 1
		→1
	§2
**




*** Алгоритм Евклида
*** https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%§1%80%D0%B8%§1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0
BNEuclAlg(L1, L2/L3)
	@+L4(1000)
	@+L5(1000)
	@+L6(1000)
	@+L7(1) 1⇒Q7 OL7.0
	*BN_gr(L1, L2/a) ↑(a>0)1 Q2⇒Q4 L2⇒L4 Q1⇒Q5 L1⇒L5 →2
	§1
		Q1⇒Q4 L1⇒L4 Q2⇒Q5 L2⇒L5
	§2
		L4;L5⇒L6 Q5⇒Q6 *cutZerosBN(L6/L6) *BN_gr(L6, L7/a) ↑(a<1)3 Q5⇒Q4 L5⇒L4 Q6⇒Q5 L6⇒L5 →2
	§3
		Q5⇒Q3 L5⇒L3
**

*** Алгоритм Евклида с приведением числа по модулю методом баррета
*** не работает(зацикливается)
BNEuclAlg_bar(L1, L2/L3)
	@+L4(1000)
	@+L5(1000)
	@+L6(1000)
	@+L7(1) 1⇒Q7 OL7.0
	@+L8(100)
	
	
	
	*BN_gr(L1, L2/a) ↑(a>0)1
	L2;L1⇒L4 Q1⇒Q4 Q1⇒Q5 L1⇒L5 →2
	/'ww\n'>C
	Q1*2⇒Q8 OL8
	Q8⇒k+1⇒Q8 1⇒L8k L8/L1⇒L8 *** L8 = z
	§1
		
		L1;L2⇒L4 Q2⇒Q4 Q2⇒Q5 L2⇒L5
		Q2*2⇒Q8 OL8
		Q8⇒k+1⇒Q8 1⇒L8k L8/L2⇒L8 *** L8 = z
	
	§2
		*barmod(L4, L5, L8/L6)
		/'qq\n'>C
		/'Q6 = '>C *printf(Q6/) /'\n'>C
		/'Q5 = '>C *printf(Q5/) /'\n'>C
		/'Q4 = '>C *printf(Q4/) /'\n'>C
		*** *cutZerosBN(L6/L6)
		*BN_gr(L6, L7/a) ↑(a<1)3 Q5⇒Q4 L5⇒L4 Q6⇒Q5 L6⇒L5 →2
	§3
		Q5⇒Q3 L5⇒L3
**



*** Расширенный алгоритм Евклида с алгоритмом баррета
*** https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%§1%80%D0%B8%§1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0#.D0.A0.D0.B0.§1.81.§1.88.D0.B8.§1.80.D0.B5.D0.BD.D0.BD.§1.8B.D0.B9_.D0.B0.D0.BB.D0.B3.D0.BE.§1.80.D0.B8.§1.82.D0.BC_.D0.95.D0.B2.D0.BA.D0.BB.D0.B8.D0.B4.D0.B0_.D0.B8_.§1.81.D0.BE.D0.BE.§1.82.D0.BD.D0.BE.§1.88.D0.B5.D0.BD.D0.B8.D0.B5_.D0.91.D0.B5.D0.B7.§1.83
extEuclAlg_bar(/)
	
	
	
**


********************************************************************************
***********************	Алгоритмы RSA закончились	************************
********************************************************************************



main(/)
   @+F1(1000) @+F2(100)
   @'liblf.l'>F2  /F2>C /'\n'>C
   *fopen(F2,0/a)
   *peper(a/)
   *freadf(a,F1,0,150/b)
   *peper(b/)
   *fclose(a/) OQ2
   @'liblf.txt'>F2 /F2>C /'\n'>C
   *fopen(F2,1/a)
   *peper(a/)
   *fwritef(a,F1,0,150/b)
   *peper(b/)
   **
********************************************************************
*** работа с файлами
********************************************************************
*** Открытие файла
*** F1 - имя файла (в текущем каталоге)
*** r - режим открытия: 0 - чтение, 1 - запись, 2 - чтение/запись
*** n  - дескриптор файла (<0 при отказе)
********************************************************************
fopen(F1,r/n)
   0@>F1
   {mov eax,5}
   {mov ebx,[ebp+220]}
   {mov ecx,[ebp+72]}
   {int 80h}
   {mov [ebp+56],eax}
   **
********************************************************************
*** Закрытие файла
*** n  - дескриптор файла
********************************************************************
fclose(n/)
   {mov eax,6}
   {mov ebx,[ebp+56]}
   {int 80h}
   **
********************************************************************
*** Чтение из файла в символьный комплекс
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого считанного байта
*** l - число запрашиваемых байт
*** k - число считанных байтов (код ошибки для <0)
********************************************************************
freadf(n,F1,b,l/k)
   {mov eax,3}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **
********************************************************************
*** Запись из символьного комплекса в файл
*** n  - дескриптор файла
*** F1 - файл
*** b - адрес в F1 первого записываемого байта
*** l - число записывемых байт
*** k - число записанных байтов (код ошибки для <0)
********************************************************************
fwritef(n,F1,b,l/k)
   {mov eax,4}
   {mov ebx,[ebp+56]}
   {mov ecx,[ebp+220]}
   {add ecx,[ebp+8]}
   {mov edx,[ebp+48]}
   {int 80h}
   {mov [ebp+44],eax}
   **

   
   
   
   
   
   
   
   
   
*** Ошибки:


matrixoutput(L1,m,n/) 
 @+F2(34)
 Oa
 §1 *binperemtostr(L1a,n/F2) ∆a
 §2 /F2>C /'\n'>C ↑(a<m)1 **



binstrtoperem(F1/x)
 Oi
 Ox
 Q1-1⇒j
*** Q1-1⇒i
 §1 ↑(F1i='0')2 x|Ij⇒x
 §2 ∇j ∆i ↑(i<Q1)1 **




out3(a,b,n/F1)
 OQ1
 n-1⇒i
 §1 a&Ii⇒x x↦2 '1'@>F1 ↑(i=0)3 ∇i →1
 §2 '0'@>F1 ↑(i=0)3 ∇i →1
 §3 /'a⇒ ' /F1>C /'\n'>C
 OQ1
 n-1⇒i
 §4 b&Ii⇒x x↦5 '0'@>F1 ↑(i=0)6 ∇i →1
 §5 '1'@>F1 ↑(i=0)6 ∇i →4
 §6 /'b⇒ ' /F1>C /'\n'>C **



*** вывод булевого вектора на экран
printbv(a, n/)
    31⇒i ∇n
 §1 ↑(i>n)3
    a&Ii ↪2 /' 1'>C →3
 §2 /' 0'>C
 §3 i↪4 ∇i →1
 §4 /'\n'>C **

*** вывод булевой матрицы на экран
printbm(L1,n/)
    Oi
 §1 *printbv(L1i,n/) ∆i ↑(i<Q1)1 /'\n'>C **
	

*** перевод числа в строку *** 

***************************************
numout(a/)
	@+F1(10)
	OQ1 
	§1	a/q⇒a Z⇒b *n(b/c) c@>F1 a↦1 
  §2	Oi Q1⇒a-1⇒j 
  §3	↑(i≥j)4  =(F1ij) ∆i ∇j →3 
  §4   ** 

 
 
binperemtostr(x,n/F1)
 OQ1
 n-1⇒i
 §1 x&Ii⇒a a↦2 '0'@>F1 ↑(i=0)3 ∇i →1
 §2 '1'@>F1 ↑(i=0)3 ∇i →1
 §3 **
